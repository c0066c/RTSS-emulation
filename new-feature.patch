From 27e1f209b80dc0bdcba244d6924675c9c994ab6d Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Thu, 4 Aug 2016 15:27:41 +0200
Subject: [PATCH 01/12] Enhance the scheduler for the timeout cases. Three
 additional functions: RM_Postponed_num, RM_Renew_deadline, and
 RM_Release_postponedjob. Four refined functions: RM_Activate,
 RM_Block_while_expired, rtems_rate_monotonic_period, RM_Timeout.
 Rate_monotonic_Control now contains one counter for counting the number of
 postponed jobs and one variable for recording the recent_deadline.

---
 cpukit/rtems/include/rtems/rtems/ratemon.h     |  14 +++
 cpukit/rtems/include/rtems/rtems/ratemonimpl.h |  22 +++++
 cpukit/rtems/src/ratemonperiod.c               | 120 +++++++++++++++++++++++--
 cpukit/rtems/src/ratemontimeout.c              |  13 +++
 4 files changed, 162 insertions(+), 7 deletions(-)

diff --git a/cpukit/rtems/include/rtems/rtems/ratemon.h b/cpukit/rtems/include/rtems/rtems/ratemon.h
index 3203eab..570eb13 100644
--- a/cpukit/rtems/include/rtems/rtems/ratemon.h
+++ b/cpukit/rtems/include/rtems/rtems/ratemon.h
@@ -229,6 +229,20 @@ typedef struct {
    * This field contains the statistics maintained for the period.
    */
   Rate_monotonic_Statistics               Statistics;
+
+  /** KHCHEN 01.08
+   * This field contains the number of postponed jobs. It is updated by
+   * the period watchdog, when the watchdog timeout, this variable will
+   * be increased immediately and the deadline of next period is renewed.
+   */
+  uint32_t                                postponed_jobs;
+
+  /** KHCHEN 02.08
+   *  This field contains the tick of the latest deadline decided by the period
+   *  watchdog.
+   */
+  uint64_t                                latest_deadline;
+
 }   Rate_monotonic_Control;

 /**
diff --git a/cpukit/rtems/include/rtems/rtems/ratemonimpl.h b/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
index 9963cab..5ead502 100644
--- a/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
+++ b/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
@@ -116,6 +116,28 @@ bool _Rate_monotonic_Get_status(
   Timestamp_Control            *cpu_since_last_period
 );

+/**
+ * Kuan-Hsun Chen, 03.08.2016
+ * This routine is prepared for the watchdog timeout to renew its deadline
+ * without releasing jobs. A postponed job induced by a deadline miss should be
+ * released by RMS manager.
+ */
+void _Rate_monotonic_Renew_deadline(
+  Rate_monotonic_Control *the_period,
+  Thread_Control         *owner,
+  ISR_lock_Context       *lock_context
+);
+
+/**
+ * Kuan-Hsun Chen, 04.08.2016
+ * This is a helper function to return the number of postponed jobs by this
+ * given period. This number is only increased by the corresponding watchdog,
+ * and is decreased by RMS manager with the postponed job releasing.
+ */
+uint32_t _Rate_monotonic_Postponed_num(
+  rtems_id                period_id
+);
+
 void _Rate_monotonic_Restart(
   Rate_monotonic_Control *the_period,
   Thread_Control         *owner,
diff --git a/cpukit/rtems/src/ratemonperiod.c b/cpukit/rtems/src/ratemonperiod.c
index 303fe17..0601270 100644
--- a/cpukit/rtems/src/ratemonperiod.c
+++ b/cpukit/rtems/src/ratemonperiod.c
@@ -63,6 +63,24 @@ bool _Rate_monotonic_Get_status(
   return true;
 }

+static void _Rate_monotonic_Release_postponedjob(
+  Rate_monotonic_Control *the_period,
+  Thread_Control         *owner,
+  rtems_interval          next_length,
+  ISR_lock_Context       *lock_context
+)
+{
+  /* This function only handles the release of postponed jobs. */
+  Per_CPU_Control *cpu_self;
+  cpu_self = _Thread_Dispatch_disable_critical( lock_context );
+  _Rate_monotonic_Release( owner, lock_context );
+
+  the_period->postponed_jobs -=1;
+  _Scheduler_Release_job( owner, the_period->latest_deadline );
+
+  _Thread_Dispatch_enable( cpu_self );
+}
+
 static void _Rate_monotonic_Release_job(
   Rate_monotonic_Control *the_period,
   Thread_Control         *owner,
@@ -89,6 +107,31 @@ static void _Rate_monotonic_Release_job(
   _Thread_Dispatch_enable( cpu_self );
 }

+void _Rate_monotonic_Renew_deadline(
+  Rate_monotonic_Control *the_period,
+  Thread_Control         *owner,
+  ISR_lock_Context       *lock_context
+)
+{
+  /*KHCHEN 03.08, Only renew the deadline called by the watchdog when it is TIMEOUT*/
+  Per_CPU_Control *cpu_self;
+  uint64_t deadline;
+
+  cpu_self = _Thread_Dispatch_disable_critical( lock_context );
+  _Rate_monotonic_Release( owner, lock_context );
+
+  _ISR_lock_ISR_disable( lock_context );
+  deadline = _Watchdog_Per_CPU_insert_relative(
+    &the_period->Timer,
+    cpu_self,
+    the_period->next_length
+  );
+  the_period->latest_deadline = deadline;
+  _ISR_lock_ISR_enable( lock_context );
+  _Thread_Dispatch_enable( cpu_self );
+
+}
+
 void _Rate_monotonic_Restart(
   Rate_monotonic_Control *the_period,
   Thread_Control         *owner,
@@ -186,6 +229,10 @@ static rtems_status_code _Rate_monotonic_Activate(
   ISR_lock_Context       *lock_context
 )
 {
+  /** KHCHEN 02.08
+   * Initialize the # of postponed job variable */
+  the_period->postponed_jobs = 0;
+
   the_period->state = RATE_MONOTONIC_ACTIVE;
   the_period->next_length = length;
   _Rate_monotonic_Restart( the_period, executing, lock_context );
@@ -244,6 +291,17 @@ static rtems_status_code _Rate_monotonic_Block_while_expired(
   ISR_lock_Context       *lock_context
 )
 {
+  /* There are two possible cases, one is that the previous deadline is missed,
+   * i.e., the state = RATE_MONOTONIC_EXPIRED. The other is that the # of postponed jobs is not 0,
+   * but the current deadline is still not expired, i.e., state = RATE_MONOTONIC_ACTIVE.
+   * However, only when the # of postponed jobs is larger than 0, we will reach this Block.
+   * It means, the just finished job is not the exact job released in the current period. Even if
+   * they are in time, they are not in the proper periods they belong to.   */
+
+  /* no matter the just finished jobs in time or not,
+   * they are actually missing their deadlines already. */
+  if(the_period->postponed_jobs > 1)
+    the_period->state = RATE_MONOTONIC_EXPIRED;
   /*
    *  Update statistics from the concluding period
    */
@@ -252,10 +310,25 @@ static rtems_status_code _Rate_monotonic_Block_while_expired(
   the_period->state = RATE_MONOTONIC_ACTIVE;
   the_period->next_length = length;

-  _Rate_monotonic_Release_job( the_period, executing, length, lock_context );
+  //KHCHEN 02.08
+//  _Rate_monotonic_Release_job( the_period, executing, length, lock_context );
+  _Rate_monotonic_Release_postponedjob( the_period, executing, length, lock_context );
   return RTEMS_TIMEOUT;
 }

+uint32_t _Rate_monotonic_Postponed_num(
+    rtems_id   period_id
+)
+{
+  /* This is a helper function to return the number of postponed jobs in the given period. */
+  Rate_monotonic_Control             *the_period;
+  ISR_lock_Context                    lock_context;
+
+  the_period = _Rate_monotonic_Get( period_id, &lock_context );
+  _Assert(the_period != NULL);
+  return the_period->postponed_jobs;
+}
+
 rtems_status_code rtems_rate_monotonic_period(
   rtems_id       id,
   rtems_interval length
@@ -288,12 +361,36 @@ rtems_status_code rtems_rate_monotonic_period(
   } else {
     switch ( state ) {
       case RATE_MONOTONIC_ACTIVE:
-        status = _Rate_monotonic_Block_while_active(
-          the_period,
-          length,
-          executing,
-          &lock_context
-        );
+
+        if(the_period->postponed_jobs > 0){
+          /* KHCHEN 03.08
+           * If there is no timeout in this period but the number of postponed
+           * jobs is not 0, it means the previous postponed instance is
+           * finished without exceeding the current period deadline.
+           *
+           * Do nothing on the watchdog deadline assignment but release the next
+           * remaining postponed job.
+           */
+
+          status = _Rate_monotonic_Block_while_expired(
+            the_period,
+            length,
+            executing,
+            &lock_context
+          );
+        }else{
+          /* KHCHEN 03.08
+           * Normal case that no postponed jobs and no expiration, so wait for the period
+           * and update the deadline of watchdog accordingly.
+           */
+
+          status = _Rate_monotonic_Block_while_active(
+            the_period,
+            length,
+            executing,
+            &lock_context
+          );
+        }
         break;
       case RATE_MONOTONIC_INACTIVE:
         status = _Rate_monotonic_Activate(
@@ -304,6 +401,15 @@ rtems_status_code rtems_rate_monotonic_period(
         );
         break;
       default:
+        /** KHCHEN 03.08
+         * As now this period was already TIMEOUT, there must be at least one
+         * postponed job recorded by the watchdog. The one which exceeded
+         * the previous deadline"s" was just finished.
+         *
+         * Maybe there is more than one job postponed due to the preemption or
+         * the previous finished job.
+         */
+
         _Assert( state == RATE_MONOTONIC_EXPIRED );
         status = _Rate_monotonic_Block_while_expired(
           the_period,
diff --git a/cpukit/rtems/src/ratemontimeout.c b/cpukit/rtems/src/ratemontimeout.c
index bd38153..44205e8 100644
--- a/cpukit/rtems/src/ratemontimeout.c
+++ b/cpukit/rtems/src/ratemontimeout.c
@@ -62,7 +62,20 @@ void _Rate_monotonic_Timeout( Watchdog_Control *the_watchdog )
       _Thread_Unblock( owner );
     }
   } else {
+#if 0
     the_period->state = RATE_MONOTONIC_EXPIRED;
     _Rate_monotonic_Release( owner, &lock_context );
+#else
+    /* KHCHEN 02.08 - revise according to Gedare suggestion
+     * If the watchdog is timeout, it means there is an additional postponed
+     * job in the next period which is not available to release job:
+     * Either the current task is still executed, or it is preemptive by the
+     * other higher priority tasks.
+     */
+
+    the_period->postponed_jobs += 1;
+    the_period->state = RATE_MONOTONIC_EXPIRED;
+    _Rate_monotonic_Renew_deadline( the_period, owner, &lock_context );
+#endif
   }
 }
--
1.9.1


From 0ce49ade2391c6626f117b37a27d42c8af4e6ced Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Thu, 4 Aug 2016 17:26:28 +0200
Subject: [PATCH 02/12] A heuristic example to show the effect of the
 enhancement in RMS manager

---
 testsuites/samples/Makefile.am              |   2 +-
 testsuites/samples/configure.ac             |   1 +
 testsuites/samples/deadlinemiss/Makefile.am |  19 ++++
 testsuites/samples/deadlinemiss/init.c      |  68 +++++++++++++
 testsuites/samples/deadlinemiss/system.h    | 142 ++++++++++++++++++++++++++
 testsuites/samples/deadlinemiss/tasks.c     | 150 ++++++++++++++++++++++++++++
 6 files changed, 381 insertions(+), 1 deletion(-)
 create mode 100644 testsuites/samples/deadlinemiss/Makefile.am
 create mode 100644 testsuites/samples/deadlinemiss/init.c
 create mode 100644 testsuites/samples/deadlinemiss/system.h
 create mode 100644 testsuites/samples/deadlinemiss/tasks.c

diff --git a/testsuites/samples/Makefile.am b/testsuites/samples/Makefile.am
index 374617b..7d5836a 100644
--- a/testsuites/samples/Makefile.am
+++ b/testsuites/samples/Makefile.am
@@ -1,6 +1,6 @@
 ACLOCAL_AMFLAGS = -I ../aclocal

-_SUBDIRS = hello capture ticker base_sp unlimited minimum fileio
+_SUBDIRS = hello capture ticker base_sp unlimited minimum fileio deadlinemiss

 if MPTESTS
 ## base_mp is a sample multiprocessing test
diff --git a/testsuites/samples/configure.ac b/testsuites/samples/configure.ac
index 91a3661..7709090 100644
--- a/testsuites/samples/configure.ac
+++ b/testsuites/samples/configure.ac
@@ -76,5 +76,6 @@ iostream/Makefile
 cdtest/Makefile
 pppd/Makefile
 capture/Makefile
+deadlinemiss/Makefile
 ])
 AC_OUTPUT
diff --git a/testsuites/samples/deadlinemiss/Makefile.am b/testsuites/samples/deadlinemiss/Makefile.am
new file mode 100644
index 0000000..bde8a45
--- /dev/null
+++ b/testsuites/samples/deadlinemiss/Makefile.am
@@ -0,0 +1,19 @@
+
+rtems_tests_PROGRAMS = deadlinemiss
+deadlinemiss_SOURCES = system.h \
+	init.c \
+	tasks.c
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+
+LINK_OBJS = $(deadlinemiss_OBJECTS)
+LINK_LIBS = $(deadlinemiss_LDLIBS) -lm
+
+deadlinemiss$(EXEEXT): $(deadlinemiss_OBJECTS) $(deadlinemiss_DEPENDENCIES)
+	@rm -f deadlinemiss$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff --git a/testsuites/samples/deadlinemiss/init.c b/testsuites/samples/deadlinemiss/init.c
new file mode 100644
index 0000000..0df3703
--- /dev/null
+++ b/testsuites/samples/deadlinemiss/init.c
@@ -0,0 +1,68 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define CEILING_POS(X) ((X-(int)(X)) > 0 ? (int)(X+1) : (int)(X))
+#define CONFIGURE_INIT
+#include "system.h"
+#include <rtems/test.h>
+#include <rtems/status-checks.h>
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int experiment_flag = 0;
+int testnumber = 15;
+rtems_id Task_id[ 2 ];
+rtems_name Task_name[ 2 ];
+uint32_t tick_per_second;
+
+rtems_task Init(
+	rtems_task_argument argument
+)
+{
+  rtems_status_code status;
+
+	tick_per_second = rtems_clock_get_ticks_per_second();
+	printf("\nTicks per second in your system: %" PRIu32 "\n", tick_per_second);
+
+  Task_name[ 1 ] = rtems_build_name( 'T', 'A', '1', ' ' );
+  Task_name[ 2 ] = rtems_build_name( 'T', 'A', '2', ' ' );
+
+
+  //Two tasks creating
+  status = rtems_task_create(
+    Task_name[ 1 ], 2, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
+    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 1 ]
+  );
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_create 1 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+  status = rtems_task_create(
+    Task_name[ 2 ], 5, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
+    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 2 ]
+  );
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_create 2 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+  //After creating the periods for tasks, start to run them sequencially.
+
+  experiment_flag = 1;
+	status = rtems_task_start( Task_id[ 1 ], Task_1, 1);
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_start 1 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+  status = rtems_task_start( Task_id[ 2 ], Task_2, 1);
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_start 2 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+	status = rtems_task_delete( RTEMS_SELF );
+}
diff --git a/testsuites/samples/deadlinemiss/system.h b/testsuites/samples/deadlinemiss/system.h
new file mode 100644
index 0000000..40511f7
--- /dev/null
+++ b/testsuites/samples/deadlinemiss/system.h
@@ -0,0 +1,142 @@
+/*
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ */
+/*  updated for SEMAPHORE test, 15/02/2016, Kuan-Hsun Chen */
+
+
+#include <inttypes.h>
+#include <rtems.h>
+
+/* functions */
+
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+rtems_task Task_1(
+  rtems_task_argument argument
+);
+
+rtems_task Task_2(
+  rtems_task_argument argument
+);
+
+
+
+/* global variables */
+
+/*
+ *  Keep the names and IDs in global variables so another task can use them.
+ */
+
+extern rtems_id   Task_id[ 2 ];         /* array of task ids */
+extern rtems_name Task_name[ 2 ];       /* array of task names */
+extern uint32_t tick_per_second;
+extern int ntask;
+extern int testnumber;
+extern int experiment_flag;
+
+/* configuration information */
+
+#include <bsp.h> /* for device driver prototypes */
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_MICROSECONDS_PER_TICK     1000   // NB: 10 and lower gives system failure for erc32 simulator
+#define CONFIGURE_MAXIMUM_TASKS             11
+#define CONFIGURE_MAXIMUM_SEMAPHORES        1
+#define CONFIGURE_MAXIMUM_PRIORITY          15
+#define CONFIGURE_EXTRA_TASK_STACKS         (20 * RTEMS_MINIMUM_STACK_SIZE)
+
+// Needed for RM Mangager
+#define CONFIGURE_MAXIMUM_PERIODS           11
+
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+
+/* Needed for erc32 simulator.. */
+/* ..for using "CPU_usage_Dump", since it uses printf("%f") if your processor has floating points) */
+/* If you want to take away FP support (to avoid heavy context switch), you must rewrite CPU_usage_Dump instead */
+//#define CONFIGURE_INIT_TASK_ATTRIBUTES RTEMS_FLOATING_POINT
+//#define CONFIGURE_INIT_TASK_INITIAL_MODES RTEMS_PREEMPT
+
+
+#include <rtems/confdefs.h>
+
+/*
+ *  Handy macros and static inline functions
+ */
+
+/*
+ *  Macro to hide the ugliness of printing the time.
+ */
+
+#define print_time(_s1, _tb, _s2) \
+  do { \
+    printf( "%s%02" PRIu32 ":%02" PRIu32 ":%02" PRIu32 \
+       "   %02" PRIu32 "/%02" PRIu32 "/%04" PRIu32 "%s", \
+       _s1, (_tb)->hour, (_tb)->minute, (_tb)->second, \
+       (_tb)->month, (_tb)->day, (_tb)->year, _s2 ); \
+    fflush(stdout); \
+  } while ( 0 )
+
+/*
+ *  Macro to print an task name that is composed of ASCII characters.
+ *
+ */
+
+#define put_name( _name, _crlf ) \
+  do { \
+    uint32_t c0, c1, c2, c3; \
+    \
+    c0 = ((_name) >> 24) & 0xff; \
+    c1 = ((_name) >> 16) & 0xff; \
+    c2 = ((_name) >> 8) & 0xff; \
+    c3 = (_name) & 0xff; \
+    putchar( (char)c0 ); \
+    if ( c1 ) putchar( (char)c1 ); \
+    if ( c2 ) putchar( (char)c2 ); \
+    if ( c3 ) putchar( (char)c3 ); \
+    if ( (_crlf) ) \
+      putchar( '\n' ); \
+  } while (0)
+
+/*
+ *  Macro to loop.
+ */
+
+
+#define LOOP(_et, taskID){ \
+  \
+  int start = 0; \
+  int now = 0; \
+  start = rtems_clock_get_ticks_since_boot();\
+  while(1){\
+	\
+    now = rtems_clock_get_ticks_since_boot();\
+	  if(now-start >= _et){\
+	  	break;\
+    }\
+ }\
+}
+
+/*
+ *  This allows us to view the "Test_task" instantiations as a set
+ *  of numbered tasks by eliminating the number of application
+ *  tasks created.
+ *
+ *  In reality, this is too complex for the purposes of this
+ *  example.  It would have been easier to pass a task argument. :)
+ *  But it shows how rtems_id's can sometimes be used.
+ */
+
+#define task_number( tid ) \
+  ( rtems_get_index( tid ) - \
+     rtems_configuration_get_rtems_api_configuration()->number_of_initialization_tasks )
+
+/* end of include file */
diff --git a/testsuites/samples/deadlinemiss/tasks.c b/testsuites/samples/deadlinemiss/tasks.c
new file mode 100644
index 0000000..f5c15ad
--- /dev/null
+++ b/testsuites/samples/deadlinemiss/tasks.c
@@ -0,0 +1,150 @@
+/**
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ */
+/*  updated for triple test, 2003/11/06, Erik Adli */
+
+#include "system.h"
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+/* CPU usage and Rate monotonic manger statistics */
+#include "rtems/cpuuse.h"
+//
+// Periods for the various tasks [seconds]
+#define PERIOD_TASK_1          10000
+#define PERIOD_TASK_2          2000
+
+
+// Task Id
+#define ID_TASK_1           0
+#define ID_TASK_2          	1
+
+// Execution time for each task
+#define task_1_normal_et	6000
+#define task_2_normal_et	1000
+
+// TASK 1
+rtems_task Task_1(
+  rtems_task_argument unused
+)
+{
+  rtems_status_code status;
+  rtems_name        period_name;
+  rtems_id          RM_period;
+  rtems_id selfid=rtems_task_self();
+  double            start, end; //sttime, entime;
+  int		    tsk_counter = 0;
+  int		    startTick = 0;
+
+  /*create period*/
+
+  period_name = rtems_build_name( 'P', 'E', 'R', '1' );
+  status = rtems_rate_monotonic_create( period_name, &RM_period );
+  if( RTEMS_SUCCESSFUL != status ) {
+    printf("RM failed with status: %d\n", status);
+    exit(1);
+  }
+
+	while( 1 ) {
+    /*this part for release offset*/
+		status = rtems_rate_monotonic_period( RM_period,PERIOD_TASK_1);
+
+		if(tsk_counter == 2){
+
+				status = rtems_rate_monotonic_delete(RM_period);
+				if(status != RTEMS_SUCCESSFUL){
+					printf("BUG: Cannot delete the period 1\n");
+					exit(1);
+				}
+
+				status=rtems_task_delete(selfid);
+				if(status != RTEMS_SUCCESSFUL){
+					printf("BUG: Cannot delete the task 1\n");
+					exit(1);
+				}
+
+		}else{
+
+			startTick = rtems_clock_get_ticks_since_boot();
+			start = startTick  / (double)tick_per_second;
+
+	    printf("Task 1 starts current second %.6f.\n", start);
+
+			LOOP(task_1_normal_et,task_id);
+
+			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
+
+			printf("					Task 1 ends at current second  %.6f .\n", end);
+ 			tsk_counter += 1;
+		}
+	}
+}
+
+// TASK 2
+rtems_task Task_2(
+  rtems_task_argument unused
+)
+{
+  rtems_id selfid=rtems_task_self();
+  rtems_status_code status;
+  rtems_name        period_name;
+  rtems_id          RM_period;
+  double 	          start, end;
+  int		            tsk_counter = 0;
+  int		            startTick = 0;
+
+  /*create period*/
+
+  period_name = rtems_build_name( 'P', 'E', 'R', '2' );
+  status = rtems_rate_monotonic_create( period_name, &RM_period );
+  if( RTEMS_SUCCESSFUL != status ) {
+    printf("RM failed with status: %d\n", status);
+    exit(1);
+  }
+
+	while( 1 ) {
+
+		/*this part for release offset*/
+		status = rtems_rate_monotonic_period( RM_period, PERIOD_TASK_2);
+
+		if(experiment_flag ==0){
+			status = rtems_rate_monotonic_delete(RM_period);
+			if(status != RTEMS_SUCCESSFUL){
+				printf("BUG: Cannot delete the period 2\n");
+				exit(1);
+			}
+      exit(1); //before delete itself, otherwise this task is dead.
+			status=rtems_task_delete(selfid);
+			if(status != RTEMS_SUCCESSFUL){
+				printf("BUG: Cannot delete the task 2\n");
+				exit(1);
+			}
+		}else{
+
+			startTick = rtems_clock_get_ticks_since_boot();
+			start = startTick  / (double)tick_per_second;
+
+			printf("Task 2 starts at current second %.6f.\n", start);
+
+			LOOP(task_2_normal_et,task_id);
+
+			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
+
+			printf("					%d Task 2 ends at current second %.6f.\n", tsk_counter+1, end);
+
+			tsk_counter += 1;
+
+      if(tsk_counter == testnumber){
+        rtems_rate_monotonic_report_statistics();
+        experiment_flag=0;
+      }
+		}
+	}
+}
+
--
1.9.1


From e028395ddeff3b48d4a30d665abe25178ceac375 Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Thu, 4 Aug 2016 19:05:22 +0200
Subject: [PATCH 03/12] Hotfix: Release thread lock missing

---
 cpukit/rtems/src/ratemonperiod.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/cpukit/rtems/src/ratemonperiod.c b/cpukit/rtems/src/ratemonperiod.c
index 0601270..4b05960 100644
--- a/cpukit/rtems/src/ratemonperiod.c
+++ b/cpukit/rtems/src/ratemonperiod.c
@@ -323,10 +323,14 @@ uint32_t _Rate_monotonic_Postponed_num(
   /* This is a helper function to return the number of postponed jobs in the given period. */
   Rate_monotonic_Control             *the_period;
   ISR_lock_Context                    lock_context;
+  Thread_Control                     *owner;

   the_period = _Rate_monotonic_Get( period_id, &lock_context );
   _Assert(the_period != NULL);
-  return the_period->postponed_jobs;
+  uint32_t jobs = the_period->postponed_instances;
+  owner = the_period->owner;
+  _Rate_monotonic_Release( owner, &lock_context );
+  return jobs;
 }

 rtems_status_code rtems_rate_monotonic_period(
--
1.9.1


From 1ca67bdee1ad332dd4acab91e72779c4642a15d8 Mon Sep 17 00:00:00 2001
From: khchen <kuan-hsun.chen@tu-dortmund.de>
Date: Fri, 5 Aug 2016 00:17:25 +0200
Subject: [PATCH 04/12] Check the convention, and move the example to
 smptests/sprmsched01

---
 testsuites/samples/Makefile.am              |   2 +-
 testsuites/samples/configure.ac             |   1 -
 testsuites/samples/deadlinemiss/Makefile.am |  19 ----
 testsuites/samples/deadlinemiss/init.c      |  68 ------------
 testsuites/samples/deadlinemiss/system.h    | 142 -------------------------
 testsuites/samples/deadlinemiss/tasks.c     | 150 ---------------------------
 testsuites/smptests/Makefile.am             |   1 +
 testsuites/smptests/configure.ac            |   1 +
 testsuites/smptests/sprmsched01/Makefile.am |  21 ++++
 testsuites/smptests/sprmsched01/init.c      |  92 +++++++++++++++++
 testsuites/smptests/sprmsched01/system.h    | 131 +++++++++++++++++++++++
 testsuites/smptests/sprmsched01/tasks.c     | 155 ++++++++++++++++++++++++++++
 12 files changed, 402 insertions(+), 381 deletions(-)
 delete mode 100644 testsuites/samples/deadlinemiss/Makefile.am
 delete mode 100644 testsuites/samples/deadlinemiss/init.c
 delete mode 100644 testsuites/samples/deadlinemiss/system.h
 delete mode 100644 testsuites/samples/deadlinemiss/tasks.c
 create mode 100644 testsuites/smptests/sprmsched01/Makefile.am
 create mode 100644 testsuites/smptests/sprmsched01/init.c
 create mode 100644 testsuites/smptests/sprmsched01/system.h
 create mode 100644 testsuites/smptests/sprmsched01/tasks.c

diff --git a/testsuites/samples/Makefile.am b/testsuites/samples/Makefile.am
index 7d5836a..374617b 100644
--- a/testsuites/samples/Makefile.am
+++ b/testsuites/samples/Makefile.am
@@ -1,6 +1,6 @@
 ACLOCAL_AMFLAGS = -I ../aclocal

-_SUBDIRS = hello capture ticker base_sp unlimited minimum fileio deadlinemiss
+_SUBDIRS = hello capture ticker base_sp unlimited minimum fileio

 if MPTESTS
 ## base_mp is a sample multiprocessing test
diff --git a/testsuites/samples/configure.ac b/testsuites/samples/configure.ac
index 7709090..91a3661 100644
--- a/testsuites/samples/configure.ac
+++ b/testsuites/samples/configure.ac
@@ -76,6 +76,5 @@ iostream/Makefile
 cdtest/Makefile
 pppd/Makefile
 capture/Makefile
-deadlinemiss/Makefile
 ])
 AC_OUTPUT
diff --git a/testsuites/samples/deadlinemiss/Makefile.am b/testsuites/samples/deadlinemiss/Makefile.am
deleted file mode 100644
index bde8a45..0000000
--- a/testsuites/samples/deadlinemiss/Makefile.am
+++ /dev/null
@@ -1,19 +0,0 @@
-
-rtems_tests_PROGRAMS = deadlinemiss
-deadlinemiss_SOURCES = system.h \
-	init.c \
-	tasks.c
-
-include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
-include $(top_srcdir)/../automake/compile.am
-include $(top_srcdir)/../automake/leaf.am
-
-
-LINK_OBJS = $(deadlinemiss_OBJECTS)
-LINK_LIBS = $(deadlinemiss_LDLIBS) -lm
-
-deadlinemiss$(EXEEXT): $(deadlinemiss_OBJECTS) $(deadlinemiss_DEPENDENCIES)
-	@rm -f deadlinemiss$(EXEEXT)
-	$(make-exe)
-
-include $(top_srcdir)/../automake/local.am
diff --git a/testsuites/samples/deadlinemiss/init.c b/testsuites/samples/deadlinemiss/init.c
deleted file mode 100644
index 0df3703..0000000
--- a/testsuites/samples/deadlinemiss/init.c
+++ /dev/null
@@ -1,68 +0,0 @@
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#define CEILING_POS(X) ((X-(int)(X)) > 0 ? (int)(X+1) : (int)(X))
-#define CONFIGURE_INIT
-#include "system.h"
-#include <rtems/test.h>
-#include <rtems/status-checks.h>
-
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-int experiment_flag = 0;
-int testnumber = 15;
-rtems_id Task_id[ 2 ];
-rtems_name Task_name[ 2 ];
-uint32_t tick_per_second;
-
-rtems_task Init(
-	rtems_task_argument argument
-)
-{
-  rtems_status_code status;
-
-	tick_per_second = rtems_clock_get_ticks_per_second();
-	printf("\nTicks per second in your system: %" PRIu32 "\n", tick_per_second);
-
-  Task_name[ 1 ] = rtems_build_name( 'T', 'A', '1', ' ' );
-  Task_name[ 2 ] = rtems_build_name( 'T', 'A', '2', ' ' );
-
-
-  //Two tasks creating
-  status = rtems_task_create(
-    Task_name[ 1 ], 2, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
-    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 1 ]
-  );
-  if ( status != RTEMS_SUCCESSFUL) {
-    printf( "rtems_task_create 1 failed with status of %d.\n", status );
-    exit( 1 );
-  }
-
-  status = rtems_task_create(
-    Task_name[ 2 ], 5, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
-    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 2 ]
-  );
-  if ( status != RTEMS_SUCCESSFUL) {
-    printf( "rtems_task_create 2 failed with status of %d.\n", status );
-    exit( 1 );
-  }
-
-  //After creating the periods for tasks, start to run them sequencially.
-
-  experiment_flag = 1;
-	status = rtems_task_start( Task_id[ 1 ], Task_1, 1);
-  if ( status != RTEMS_SUCCESSFUL) {
-    printf( "rtems_task_start 1 failed with status of %d.\n", status );
-    exit( 1 );
-  }
-  status = rtems_task_start( Task_id[ 2 ], Task_2, 1);
-  if ( status != RTEMS_SUCCESSFUL) {
-    printf( "rtems_task_start 2 failed with status of %d.\n", status );
-    exit( 1 );
-  }
-
-	status = rtems_task_delete( RTEMS_SELF );
-}
diff --git a/testsuites/samples/deadlinemiss/system.h b/testsuites/samples/deadlinemiss/system.h
deleted file mode 100644
index 40511f7..0000000
--- a/testsuites/samples/deadlinemiss/system.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- *
- *  COPYRIGHT (c) 1989-2007.
- *  On-Line Applications Research Corporation (OAR).
- *
- *  The license and distribution terms for this file may be
- *  found in the file LICENSE in this distribution or at
- *  http://www.rtems.com/license/LICENSE.
- */
-/*  updated for SEMAPHORE test, 15/02/2016, Kuan-Hsun Chen */
-
-
-#include <inttypes.h>
-#include <rtems.h>
-
-/* functions */
-
-rtems_task Init(
-  rtems_task_argument argument
-);
-
-rtems_task Task_1(
-  rtems_task_argument argument
-);
-
-rtems_task Task_2(
-  rtems_task_argument argument
-);
-
-
-
-/* global variables */
-
-/*
- *  Keep the names and IDs in global variables so another task can use them.
- */
-
-extern rtems_id   Task_id[ 2 ];         /* array of task ids */
-extern rtems_name Task_name[ 2 ];       /* array of task names */
-extern uint32_t tick_per_second;
-extern int ntask;
-extern int testnumber;
-extern int experiment_flag;
-
-/* configuration information */
-
-#include <bsp.h> /* for device driver prototypes */
-
-#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
-#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
-#define CONFIGURE_MICROSECONDS_PER_TICK     1000   // NB: 10 and lower gives system failure for erc32 simulator
-#define CONFIGURE_MAXIMUM_TASKS             11
-#define CONFIGURE_MAXIMUM_SEMAPHORES        1
-#define CONFIGURE_MAXIMUM_PRIORITY          15
-#define CONFIGURE_EXTRA_TASK_STACKS         (20 * RTEMS_MINIMUM_STACK_SIZE)
-
-// Needed for RM Mangager
-#define CONFIGURE_MAXIMUM_PERIODS           11
-
-#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
-
-/* Needed for erc32 simulator.. */
-/* ..for using "CPU_usage_Dump", since it uses printf("%f") if your processor has floating points) */
-/* If you want to take away FP support (to avoid heavy context switch), you must rewrite CPU_usage_Dump instead */
-//#define CONFIGURE_INIT_TASK_ATTRIBUTES RTEMS_FLOATING_POINT
-//#define CONFIGURE_INIT_TASK_INITIAL_MODES RTEMS_PREEMPT
-
-
-#include <rtems/confdefs.h>
-
-/*
- *  Handy macros and static inline functions
- */
-
-/*
- *  Macro to hide the ugliness of printing the time.
- */
-
-#define print_time(_s1, _tb, _s2) \
-  do { \
-    printf( "%s%02" PRIu32 ":%02" PRIu32 ":%02" PRIu32 \
-       "   %02" PRIu32 "/%02" PRIu32 "/%04" PRIu32 "%s", \
-       _s1, (_tb)->hour, (_tb)->minute, (_tb)->second, \
-       (_tb)->month, (_tb)->day, (_tb)->year, _s2 ); \
-    fflush(stdout); \
-  } while ( 0 )
-
-/*
- *  Macro to print an task name that is composed of ASCII characters.
- *
- */
-
-#define put_name( _name, _crlf ) \
-  do { \
-    uint32_t c0, c1, c2, c3; \
-    \
-    c0 = ((_name) >> 24) & 0xff; \
-    c1 = ((_name) >> 16) & 0xff; \
-    c2 = ((_name) >> 8) & 0xff; \
-    c3 = (_name) & 0xff; \
-    putchar( (char)c0 ); \
-    if ( c1 ) putchar( (char)c1 ); \
-    if ( c2 ) putchar( (char)c2 ); \
-    if ( c3 ) putchar( (char)c3 ); \
-    if ( (_crlf) ) \
-      putchar( '\n' ); \
-  } while (0)
-
-/*
- *  Macro to loop.
- */
-
-
-#define LOOP(_et, taskID){ \
-  \
-  int start = 0; \
-  int now = 0; \
-  start = rtems_clock_get_ticks_since_boot();\
-  while(1){\
-	\
-    now = rtems_clock_get_ticks_since_boot();\
-	  if(now-start >= _et){\
-	  	break;\
-    }\
- }\
-}
-
-/*
- *  This allows us to view the "Test_task" instantiations as a set
- *  of numbered tasks by eliminating the number of application
- *  tasks created.
- *
- *  In reality, this is too complex for the purposes of this
- *  example.  It would have been easier to pass a task argument. :)
- *  But it shows how rtems_id's can sometimes be used.
- */
-
-#define task_number( tid ) \
-  ( rtems_get_index( tid ) - \
-     rtems_configuration_get_rtems_api_configuration()->number_of_initialization_tasks )
-
-/* end of include file */
diff --git a/testsuites/samples/deadlinemiss/tasks.c b/testsuites/samples/deadlinemiss/tasks.c
deleted file mode 100644
index f5c15ad..0000000
--- a/testsuites/samples/deadlinemiss/tasks.c
+++ /dev/null
@@ -1,150 +0,0 @@
-/**
- *  COPYRIGHT (c) 1989-2007.
- *  On-Line Applications Research Corporation (OAR).
- *
- *  The license and distribution terms for this file may be
- *  found in the file LICENSE in this distribution or at
- *  http://www.rtems.com/license/LICENSE.
- */
-/*  updated for triple test, 2003/11/06, Erik Adli */
-
-#include "system.h"
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-/* CPU usage and Rate monotonic manger statistics */
-#include "rtems/cpuuse.h"
-//
-// Periods for the various tasks [seconds]
-#define PERIOD_TASK_1          10000
-#define PERIOD_TASK_2          2000
-
-
-// Task Id
-#define ID_TASK_1           0
-#define ID_TASK_2          	1
-
-// Execution time for each task
-#define task_1_normal_et	6000
-#define task_2_normal_et	1000
-
-// TASK 1
-rtems_task Task_1(
-  rtems_task_argument unused
-)
-{
-  rtems_status_code status;
-  rtems_name        period_name;
-  rtems_id          RM_period;
-  rtems_id selfid=rtems_task_self();
-  double            start, end; //sttime, entime;
-  int		    tsk_counter = 0;
-  int		    startTick = 0;
-
-  /*create period*/
-
-  period_name = rtems_build_name( 'P', 'E', 'R', '1' );
-  status = rtems_rate_monotonic_create( period_name, &RM_period );
-  if( RTEMS_SUCCESSFUL != status ) {
-    printf("RM failed with status: %d\n", status);
-    exit(1);
-  }
-
-	while( 1 ) {
-    /*this part for release offset*/
-		status = rtems_rate_monotonic_period( RM_period,PERIOD_TASK_1);
-
-		if(tsk_counter == 2){
-
-				status = rtems_rate_monotonic_delete(RM_period);
-				if(status != RTEMS_SUCCESSFUL){
-					printf("BUG: Cannot delete the period 1\n");
-					exit(1);
-				}
-
-				status=rtems_task_delete(selfid);
-				if(status != RTEMS_SUCCESSFUL){
-					printf("BUG: Cannot delete the task 1\n");
-					exit(1);
-				}
-
-		}else{
-
-			startTick = rtems_clock_get_ticks_since_boot();
-			start = startTick  / (double)tick_per_second;
-
-	    printf("Task 1 starts current second %.6f.\n", start);
-
-			LOOP(task_1_normal_et,task_id);
-
-			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
-
-			printf("					Task 1 ends at current second  %.6f .\n", end);
- 			tsk_counter += 1;
-		}
-	}
-}
-
-// TASK 2
-rtems_task Task_2(
-  rtems_task_argument unused
-)
-{
-  rtems_id selfid=rtems_task_self();
-  rtems_status_code status;
-  rtems_name        period_name;
-  rtems_id          RM_period;
-  double 	          start, end;
-  int		            tsk_counter = 0;
-  int		            startTick = 0;
-
-  /*create period*/
-
-  period_name = rtems_build_name( 'P', 'E', 'R', '2' );
-  status = rtems_rate_monotonic_create( period_name, &RM_period );
-  if( RTEMS_SUCCESSFUL != status ) {
-    printf("RM failed with status: %d\n", status);
-    exit(1);
-  }
-
-	while( 1 ) {
-
-		/*this part for release offset*/
-		status = rtems_rate_monotonic_period( RM_period, PERIOD_TASK_2);
-
-		if(experiment_flag ==0){
-			status = rtems_rate_monotonic_delete(RM_period);
-			if(status != RTEMS_SUCCESSFUL){
-				printf("BUG: Cannot delete the period 2\n");
-				exit(1);
-			}
-      exit(1); //before delete itself, otherwise this task is dead.
-			status=rtems_task_delete(selfid);
-			if(status != RTEMS_SUCCESSFUL){
-				printf("BUG: Cannot delete the task 2\n");
-				exit(1);
-			}
-		}else{
-
-			startTick = rtems_clock_get_ticks_since_boot();
-			start = startTick  / (double)tick_per_second;
-
-			printf("Task 2 starts at current second %.6f.\n", start);
-
-			LOOP(task_2_normal_et,task_id);
-
-			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
-
-			printf("					%d Task 2 ends at current second %.6f.\n", tsk_counter+1, end);
-
-			tsk_counter += 1;
-
-      if(tsk_counter == testnumber){
-        rtems_rate_monotonic_report_statistics();
-        experiment_flag=0;
-      }
-		}
-	}
-}
-
diff --git a/testsuites/smptests/Makefile.am b/testsuites/smptests/Makefile.am
index 02d1dfc..b943a4e 100644
--- a/testsuites/smptests/Makefile.am
+++ b/testsuites/smptests/Makefile.am
@@ -43,6 +43,7 @@ SUBDIRS += smpswitchextension01
 SUBDIRS += smpthreadlife01
 SUBDIRS += smpunsupported01
 SUBDIRS += smpwakeafter01
+SUBDIRS += sprmsched01
 if HAS_POSIX
 SUBDIRS += smppsxaffinity01
 SUBDIRS += smppsxaffinity02
diff --git a/testsuites/smptests/configure.ac b/testsuites/smptests/configure.ac
index 8c8476f..a249729 100644
--- a/testsuites/smptests/configure.ac
+++ b/testsuites/smptests/configure.ac
@@ -102,5 +102,6 @@ smpswitchextension01/Makefile
 smpthreadlife01/Makefile
 smpunsupported01/Makefile
 smpwakeafter01/Makefile
+sprmsched01/Makefile
 ])
 AC_OUTPUT
diff --git a/testsuites/smptests/sprmsched01/Makefile.am b/testsuites/smptests/sprmsched01/Makefile.am
new file mode 100644
index 0000000..f21fdb7
--- /dev/null
+++ b/testsuites/smptests/sprmsched01/Makefile.am
@@ -0,0 +1,21 @@
+
+rtems_tests_PROGRAMS = sprmsched01
+sprmsched01_SOURCES = system.h \
+	init.c \
+	tasks.c
+
+dist_rtems_tests_DATA = sprmsched01.scn sprmsched01.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+
+LINK_OBJS = $(deadlinemiss_OBJECTS)
+LINK_LIBS = $(deadlinemiss_LDLIBS) -lm
+
+sprmsched01$(EXEEXT): $(sprmsched01_OBJECTS) $(sprmsched01_DEPENDENCIES)
+	@rm -f sprmsched01$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff --git a/testsuites/smptests/sprmsched01/init.c b/testsuites/smptests/sprmsched01/init.c
new file mode 100644
index 0000000..6a2a9fe
--- /dev/null
+++ b/testsuites/smptests/sprmsched01/init.c
@@ -0,0 +1,92 @@
+/**
+ * @file sprmsched01/tasks.c
+ *
+ * @brief A heuristic example to demonstrate how the postponed jobs are handled.
+ *
+ * Given two tasks with implicit deadline. To force deadline misses, we reverse
+ * the rate-monotonic priority assignment and only execute the highest priority
+ * task twice. In the original implementation, no matter how many periods are
+ * expired, RMS manager only releases a job with a shifted deadline assignment
+ * in the watchdog.
+ *
+ * In more general real-time task model, e.g., soft real-time task, the postponed
+ * jobs are still required to be released when the task is available to execute.
+ */
+
+/*
+ * COPYRIGHT (c) 2016, Kuan-Hsun Chen.
+ * TU Dortmund, Germany.
+ *
+ * The license and distribution terms for this file may be
+ * found in the file LICENSE in this distribution or at
+ * http://www.rtems.com/license/LICENSE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define CEILING_POS(X) ((X-(int)(X)) > 0 ? (int)(X+1) : (int)(X))
+#define CONFIGURE_INIT
+#include "system.h"
+#include <rtems/test.h>
+#include <rtems/status-checks.h>
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+/* Global variables */
+int experiment_flag = 0;
+int testnumber = 15;
+rtems_id Task_id[ 2 ];
+rtems_name Task_name[ 2 ];
+uint32_t tick_per_second;
+
+rtems_task Init(
+	rtems_task_argument argument
+)
+{
+  rtems_status_code status;
+
+  tick_per_second = rtems_clock_get_ticks_per_second();
+  printf("\nTicks per second in your system: %" PRIu32 "\n", tick_per_second);
+
+  Task_name[ 1 ] = rtems_build_name( 'T', 'A', '1', ' ' );
+  Task_name[ 2 ] = rtems_build_name( 'T', 'A', '2', ' ' );
+
+  /* Create two tasks */
+  status = rtems_task_create(
+    Task_name[ 1 ], 2, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
+    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 1 ]
+  );
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_create 1 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+  status = rtems_task_create(
+    Task_name[ 2 ], 5, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
+    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 2 ]
+  );
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_create 2 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+  /* After creating the periods for tasks, start to run them sequencially. */
+
+  experiment_flag = 1;
+  status = rtems_task_start( Task_id[ 1 ], Task_1, 1);
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_start 1 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+  status = rtems_task_start( Task_id[ 2 ], Task_2, 1);
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_start 2 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+  status = rtems_task_delete( RTEMS_SELF );
+}
diff --git a/testsuites/smptests/sprmsched01/system.h b/testsuites/smptests/sprmsched01/system.h
new file mode 100644
index 0000000..4ce8898
--- /dev/null
+++ b/testsuites/smptests/sprmsched01/system.h
@@ -0,0 +1,131 @@
+/**
+ * @file sprmsched01/system.h
+ *
+ * @brief Example header
+ */
+
+/*
+ *  COPYRIGHT (c) 2016, Kuan-Hsun Chen.
+ *  TU Dortmund, Germany.
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ */
+
+#include <inttypes.h>
+#include <rtems.h>
+
+/* function prototypes */
+
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+rtems_task Task_1(
+  rtems_task_argument argument
+);
+
+rtems_task Task_2(
+  rtems_task_argument argument
+);
+
+/*
+ *  Keep the names and IDs in global variables so another task can use them.
+ */
+
+extern rtems_id   Task_id[ 2 ];         /* array of task ids */
+extern rtems_name Task_name[ 2 ];       /* array of task names */
+extern uint32_t tick_per_second;
+extern int ntask;
+extern int testnumber;
+extern int experiment_flag;
+
+/* configuration information */
+
+#include <bsp.h> /* for device driver prototypes */
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_MICROSECONDS_PER_TICK     1000   // NB: 10 and lower gives system failure for erc32 simulator
+#define CONFIGURE_MAXIMUM_TASKS             3
+#define CONFIGURE_MAXIMUM_SEMAPHORES        1
+#define CONFIGURE_MAXIMUM_PRIORITY          15
+#define CONFIGURE_EXTRA_TASK_STACKS         (20 * RTEMS_MINIMUM_STACK_SIZE)
+#define CONFIGURE_MAXIMUM_PERIODS           3
+
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+
+#include <rtems/confdefs.h>
+
+/*
+ *  Macro to hide the ugliness of printing the time.
+ */
+
+#define print_time(_s1, _tb, _s2) \
+  do { \
+    printf( "%s%02" PRIu32 ":%02" PRIu32 ":%02" PRIu32 \
+       "   %02" PRIu32 "/%02" PRIu32 "/%04" PRIu32 "%s", \
+       _s1, (_tb)->hour, (_tb)->minute, (_tb)->second, \
+       (_tb)->month, (_tb)->day, (_tb)->year, _s2 ); \
+    fflush(stdout); \
+  } while ( 0 )
+
+/*
+ *  Macro to print an task name that is composed of ASCII characters.
+ *
+ */
+
+#define put_name( _name, _crlf ) \
+  do { \
+    uint32_t c0, c1, c2, c3; \
+    \
+    c0 = ((_name) >> 24) & 0xff; \
+    c1 = ((_name) >> 16) & 0xff; \
+    c2 = ((_name) >> 8) & 0xff; \
+    c3 = (_name) & 0xff; \
+    putchar( (char)c0 ); \
+    if ( c1 ) putchar( (char)c1 ); \
+    if ( c2 ) putchar( (char)c2 ); \
+    if ( c3 ) putchar( (char)c3 ); \
+    if ( (_crlf) ) \
+      putchar( '\n' ); \
+  } while (0)
+
+/*
+ *  Macro to loop/simulate the execution time.
+ */
+
+
+#define LOOP(_et, taskID){ \
+  \
+  int start = 0; \
+  int now = 0; \
+  start = rtems_clock_get_ticks_since_boot();\
+  while(1){\
+	\
+    now = rtems_clock_get_ticks_since_boot();\
+	  if(now-start >= _et){\
+	  	break;\
+    }\
+ }\
+}
+
+/*
+ *  This allows us to view the "Test_task" instantiations as a set
+ *  of numbered tasks by eliminating the number of application
+ *  tasks created.
+ *
+ *  In reality, this is too complex for the purposes of this
+ *  example.  It would have been easier to pass a task argument. :)
+ *  But it shows how rtems_id's can sometimes be used.
+ */
+
+#define task_number( tid ) \
+  ( rtems_get_index( tid ) - \
+     rtems_configuration_get_rtems_api_configuration()->number_of_initialization_tasks )
+
+/* end of include file */
diff --git a/testsuites/smptests/sprmsched01/tasks.c b/testsuites/smptests/sprmsched01/tasks.c
new file mode 100644
index 0000000..93ca241
--- /dev/null
+++ b/testsuites/smptests/sprmsched01/tasks.c
@@ -0,0 +1,155 @@
+/**
+ * @file sprmsched01/tasks.c
+ *
+ * @brief A heuristic example to demonstrate how the postponed jobs are handled.
+ *
+ * Given two tasks with implicit deadline. To force deadline misses, we reverse
+ * the rate-monotonic priority assignment and only execute the highest priority
+ * task twice. In the original implementation, no matter how many periods are
+ * expired, RMS manager only releases a job with a shifted deadline assignment
+ * in the watchdog.
+ *
+ * In more general real-time task model, e.g., soft real-time task, the postponed
+ * jobs are still required to be released when the task is available to execute.
+ */
+
+/*
+ *  COPYRIGHT (c) 2016, Kuan-Hsun Chen.
+ *  TU Dortmund, Germany.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ */
+
+#include "system.h"
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+/* CPU usage and Rate monotonic manger statistics */
+#include "rtems/cpuuse.h"
+
+/* Periods for the various tasks [ticks] */
+#define PERIOD_TASK_1          10000
+#define PERIOD_TASK_2          2000
+
+/* Task Id */
+#define ID_TASK_1           0
+#define ID_TASK_2          	1
+
+/* Execution time for each task [ticks] */
+#define task_1_normal_et	6000
+#define task_2_normal_et	1000
+
+rtems_task Task_1(
+  rtems_task_argument unused
+)
+{
+  rtems_status_code status;
+  rtems_name        period_name;
+  rtems_id          RM_period;
+  rtems_id 			selfid=rtems_task_self();
+  double            start, end;
+  int		    	tsk_counter = 0;
+  int		    	startTick = 0;
+
+  /*create period*/
+  period_name = rtems_build_name( 'P', 'E', 'R', '1' );
+  status = rtems_rate_monotonic_create( period_name, &RM_period );
+  if( RTEMS_SUCCESSFUL != status ) {
+    printf("RM failed with status: %d\n", status);
+    exit(1);
+  }
+
+	while( 1 ) {
+		status = rtems_rate_monotonic_period( RM_period,PERIOD_TASK_1);
+
+		if(tsk_counter == 2){
+
+				status = rtems_rate_monotonic_delete(RM_period);
+				if(status != RTEMS_SUCCESSFUL){
+					printf("BUG: Cannot delete the period 1\n");
+					exit(1);
+				}
+
+				status=rtems_task_delete(selfid);
+				if(status != RTEMS_SUCCESSFUL){
+					printf("BUG: Cannot delete the task 1\n");
+					exit(1);
+				}
+
+		}else{
+
+			startTick = rtems_clock_get_ticks_since_boot();
+			start = startTick  / (double)tick_per_second;
+
+			printf("Task 1 starts current second %.6f.\n", start);
+
+			LOOP(task_1_normal_et,task_id);
+
+			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
+
+			printf("					Task 1 ends at current second  %.6f .\n", end);
+ 			tsk_counter += 1;
+		}
+	}
+}
+
+rtems_task Task_2(
+  rtems_task_argument unused
+)
+{
+  rtems_id selfid=rtems_task_self();
+  rtems_status_code status;
+  rtems_name        period_name;
+  rtems_id          RM_period;
+  double 	        start, end;
+  int		        tsk_counter = 0;
+  int		        startTick = 0;
+
+  /*create period*/
+
+  period_name = rtems_build_name( 'P', 'E', 'R', '2' );
+  status = rtems_rate_monotonic_create( period_name, &RM_period );
+  if( RTEMS_SUCCESSFUL != status ) {
+    printf("RM failed with status: %d\n", status);
+    exit(1);
+  }
+
+	while( 1 ) {
+
+		/*this part for release offset*/
+		status = rtems_rate_monotonic_period( RM_period, PERIOD_TASK_2);
+
+		if(experiment_flag ==0){
+			status = rtems_rate_monotonic_delete(RM_period);
+			if(status != RTEMS_SUCCESSFUL){
+				printf("BUG: Cannot delete the period 2\n");
+				exit(1);
+			}
+			/* The example is finished */
+			exit(1);
+		}else{
+
+			startTick = rtems_clock_get_ticks_since_boot();
+			start = startTick  / (double)tick_per_second;
+
+			printf("Task 2 starts at current second %.6f.\n", start);
+
+			LOOP(task_2_normal_et,task_id);
+
+			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
+
+			printf("					%d Task 2 ends at current second %.6f.\n", tsk_counter+1, end);
+
+			tsk_counter += 1;
+
+			if(tsk_counter == testnumber){
+			  rtems_rate_monotonic_report_statistics();
+			  experiment_flag=0;
+			}
+		}
+	}
+}
+
--
1.9.1


From 849405dfe0e3bba423d2ac08dfc1b02b95bdf491 Mon Sep 17 00:00:00 2001
From: khchen <kuan-hsun.chen@tu-dortmund.de>
Date: Fri, 5 Aug 2016 01:38:18 +0200
Subject: [PATCH 05/12] Refine the enhanced functions with the coding
 conventions.

---
 cpukit/rtems/include/rtems/rtems/ratemon.h     | 27 +++++++++---
 cpukit/rtems/include/rtems/rtems/ratemonimpl.h | 17 ++------
 cpukit/rtems/src/ratemonperiod.c               | 57 ++++++++++++--------------
 cpukit/rtems/src/ratemontimeout.c              | 12 ++----
 testsuites/smptests/sprmsched01/init.c         | 23 +++--------
 testsuites/smptests/sprmsched01/system.h       | 15 ++++---
 testsuites/smptests/sprmsched01/tasks.c        |  9 +++-
 7 files changed, 77 insertions(+), 83 deletions(-)

diff --git a/cpukit/rtems/include/rtems/rtems/ratemon.h b/cpukit/rtems/include/rtems/rtems/ratemon.h
index 570eb13..71a99dc 100644
--- a/cpukit/rtems/include/rtems/rtems/ratemon.h
+++ b/cpukit/rtems/include/rtems/rtems/ratemon.h
@@ -22,6 +22,7 @@

 /* COPYRIGHT (c) 1989-2009, 2016.
  * On-Line Applications Research Corporation (OAR).
+ * COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
  *
  * The license and distribution terms for this file may be
  * found in the file LICENSE in this distribution or at
@@ -230,14 +231,13 @@ typedef struct {
    */
   Rate_monotonic_Statistics               Statistics;

-  /** KHCHEN 01.08
-   * This field contains the number of postponed jobs. It is updated by
-   * the period watchdog, when the watchdog timeout, this variable will
-   * be increased immediately and the deadline of next period is renewed.
+  /**
+   * This field contains the number of postponed jobs. When the watchdog timeout,
+   * this variable will be increased immediately.
    */
   uint32_t                                postponed_jobs;

-  /** KHCHEN 02.08
+  /**
    *  This field contains the tick of the latest deadline decided by the period
    *  watchdog.
    */
@@ -389,6 +389,23 @@ void rtems_rate_monotonic_report_statistics_with_plugin(
 void rtems_rate_monotonic_report_statistics( void );

 /**
+ * @brief RTEMS Return the number of postponed jobs
+ *
+ * This is a helper function to return the number of postponed jobs by this
+ * given period. This number is only increased by the corresponding watchdog,
+ * and is decreased by RMS manager with the postponed job releasing.
+ *
+ * @param[in] id is the period id
+ *
+ * @retval This helper function returns the number of postponed
+ * jobs with given period_id.
+ *
+ */
+uint32_t rtems_rate_monotonic_Postponed_num(
+  rtems_id        period_id
+);
+
+/**
  * @brief RTEMS Rate Monotonic Period
  *
  * This routine implements the rtems_rate_monotonic_period directive. When
diff --git a/cpukit/rtems/include/rtems/rtems/ratemonimpl.h b/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
index 5ead502..6cdaaeb 100644
--- a/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
+++ b/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
@@ -9,6 +9,7 @@
 /*  COPYRIGHT (c) 1989-2008.
  *  On-Line Applications Research Corporation (OAR).
  *  Copyright (c) 2016 embedded brains GmbH.
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
  *
  *  The license and distribution terms for this file may be
  *  found in the file LICENSE in this distribution or at
@@ -117,10 +118,10 @@ bool _Rate_monotonic_Get_status(
 );

 /**
- * Kuan-Hsun Chen, 03.08.2016
+ * @brief Renew the watchdog deadline
+ *
  * This routine is prepared for the watchdog timeout to renew its deadline
- * without releasing jobs. A postponed job induced by a deadline miss should be
- * released by RMS manager.
+ * without releasing jobs.
  */
 void _Rate_monotonic_Renew_deadline(
   Rate_monotonic_Control *the_period,
@@ -128,16 +129,6 @@ void _Rate_monotonic_Renew_deadline(
   ISR_lock_Context       *lock_context
 );

-/**
- * Kuan-Hsun Chen, 04.08.2016
- * This is a helper function to return the number of postponed jobs by this
- * given period. This number is only increased by the corresponding watchdog,
- * and is decreased by RMS manager with the postponed job releasing.
- */
-uint32_t _Rate_monotonic_Postponed_num(
-  rtems_id                period_id
-);
-
 void _Rate_monotonic_Restart(
   Rate_monotonic_Control *the_period,
   Thread_Control         *owner,
diff --git a/cpukit/rtems/src/ratemonperiod.c b/cpukit/rtems/src/ratemonperiod.c
index 4b05960..296d19b 100644
--- a/cpukit/rtems/src/ratemonperiod.c
+++ b/cpukit/rtems/src/ratemonperiod.c
@@ -9,6 +9,7 @@
  *  COPYRIGHT (c) 1989-2010.
  *  On-Line Applications Research Corporation (OAR).
  *  Copyright (c) 2016 embedded brains GmbH.
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
  *
  *  The license and distribution terms for this file may be
  *  found in the file LICENSE in this distribution or at
@@ -70,7 +71,7 @@ static void _Rate_monotonic_Release_postponedjob(
   ISR_lock_Context       *lock_context
 )
 {
-  /* This function only handles the release of postponed jobs. */
+  /* This function only releases the postponed jobs. */
   Per_CPU_Control *cpu_self;
   cpu_self = _Thread_Dispatch_disable_critical( lock_context );
   _Rate_monotonic_Release( owner, lock_context );
@@ -113,7 +114,6 @@ void _Rate_monotonic_Renew_deadline(
   ISR_lock_Context       *lock_context
 )
 {
-  /*KHCHEN 03.08, Only renew the deadline called by the watchdog when it is TIMEOUT*/
   Per_CPU_Control *cpu_self;
   uint64_t deadline;

@@ -229,8 +229,8 @@ static rtems_status_code _Rate_monotonic_Activate(
   ISR_lock_Context       *lock_context
 )
 {
-  /** KHCHEN 02.08
-   * Initialize the # of postponed job variable */
+
+  /* Initialize the number of postponed job variable */
   the_period->postponed_jobs = 0;

   the_period->state = RATE_MONOTONIC_ACTIVE;
@@ -284,6 +284,11 @@ static rtems_status_code _Rate_monotonic_Block_while_active(
   return RTEMS_SUCCESSFUL;
 }

+/*
+ * There are two possible cases: one is that the previous deadline is missed,
+ * The other is that the number of postponed jobs is not 0, but the current
+ * deadline is still not expired, i.e., state = RATE_MONOTONIC_ACTIVE.
+ */
 static rtems_status_code _Rate_monotonic_Block_while_expired(
   Rate_monotonic_Control *the_period,
   rtems_interval          length,
@@ -291,17 +296,15 @@ static rtems_status_code _Rate_monotonic_Block_while_expired(
   ISR_lock_Context       *lock_context
 )
 {
-  /* There are two possible cases, one is that the previous deadline is missed,
-   * i.e., the state = RATE_MONOTONIC_EXPIRED. The other is that the # of postponed jobs is not 0,
-   * but the current deadline is still not expired, i.e., state = RATE_MONOTONIC_ACTIVE.
-   * However, only when the # of postponed jobs is larger than 0, we will reach this Block.
-   * It means, the just finished job is not the exact job released in the current period. Even if
-   * they are in time, they are not in the proper periods they belong to.   */
-
-  /* no matter the just finished jobs in time or not,
-   * they are actually missing their deadlines already. */
+  /*
+   * No matter the just finished jobs in time or not,
+   * they are actually missing their deadlines already.
+   * However, maybe the latest postponed job is exactly
+   * the one released in the current period.
+   */
   if(the_period->postponed_jobs > 1)
     the_period->state = RATE_MONOTONIC_EXPIRED;
+
   /*
    *  Update statistics from the concluding period
    */
@@ -309,18 +312,15 @@ static rtems_status_code _Rate_monotonic_Block_while_expired(

   the_period->state = RATE_MONOTONIC_ACTIVE;
   the_period->next_length = length;
-
-  //KHCHEN 02.08
-//  _Rate_monotonic_Release_job( the_period, executing, length, lock_context );
+
   _Rate_monotonic_Release_postponedjob( the_period, executing, length, lock_context );
   return RTEMS_TIMEOUT;
 }

-uint32_t _Rate_monotonic_Postponed_num(
+uint32_t rtems_rate_monotonic_Postponed_num(
     rtems_id   period_id
 )
-{
-  /* This is a helper function to return the number of postponed jobs in the given period. */
+{
   Rate_monotonic_Control             *the_period;
   ISR_lock_Context                    lock_context;
   Thread_Control                     *owner;
@@ -367,15 +367,14 @@ rtems_status_code rtems_rate_monotonic_period(
       case RATE_MONOTONIC_ACTIVE:

         if(the_period->postponed_jobs > 0){
-          /* KHCHEN 03.08
-           * If there is no timeout in this period but the number of postponed
-           * jobs is not 0, it means the previous postponed instance is
-           * finished without exceeding the current period deadline.
+          /*
+           * If the number of postponed jobs is not 0, it means the
+		   * previous postponed instance is finished without exceeding
+		   * the current period deadline.
            *
            * Do nothing on the watchdog deadline assignment but release the next
            * remaining postponed job.
-           */
-
+           */
           status = _Rate_monotonic_Block_while_expired(
             the_period,
             length,
@@ -383,11 +382,10 @@ rtems_status_code rtems_rate_monotonic_period(
             &lock_context
           );
         }else{
-          /* KHCHEN 03.08
+          /*
            * Normal case that no postponed jobs and no expiration, so wait for the period
            * and update the deadline of watchdog accordingly.
-           */
-
+           */
           status = _Rate_monotonic_Block_while_active(
             the_period,
             length,
@@ -405,7 +403,7 @@ rtems_status_code rtems_rate_monotonic_period(
         );
         break;
       default:
-        /** KHCHEN 03.08
+        /*
          * As now this period was already TIMEOUT, there must be at least one
          * postponed job recorded by the watchdog. The one which exceeded
          * the previous deadline"s" was just finished.
@@ -413,7 +411,6 @@ rtems_status_code rtems_rate_monotonic_period(
          * Maybe there is more than one job postponed due to the preemption or
          * the previous finished job.
          */
-
         _Assert( state == RATE_MONOTONIC_EXPIRED );
         status = _Rate_monotonic_Block_while_expired(
           the_period,
diff --git a/cpukit/rtems/src/ratemontimeout.c b/cpukit/rtems/src/ratemontimeout.c
index 44205e8..be0a770 100644
--- a/cpukit/rtems/src/ratemontimeout.c
+++ b/cpukit/rtems/src/ratemontimeout.c
@@ -9,6 +9,8 @@
  *  COPYRIGHT (c) 1989-2009.
  *  On-Line Applications Research Corporation (OAR).
  *
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
+ *
  *  The license and distribution terms for this file may be
  *  found in the file LICENSE in this distribution or at
  *  http://www.rtems.org/license/LICENSE.
@@ -62,20 +64,14 @@ void _Rate_monotonic_Timeout( Watchdog_Control *the_watchdog )
       _Thread_Unblock( owner );
     }
   } else {
-#if 0
-    the_period->state = RATE_MONOTONIC_EXPIRED;
-    _Rate_monotonic_Release( owner, &lock_context );
-#else
-    /* KHCHEN 02.08 - revise according to Gedare suggestion
+    /*
      * If the watchdog is timeout, it means there is an additional postponed
-     * job in the next period which is not available to release job:
+     * job in the next period but it is not available to release now:
      * Either the current task is still executed, or it is preemptive by the
      * other higher priority tasks.
      */
-
     the_period->postponed_jobs += 1;
     the_period->state = RATE_MONOTONIC_EXPIRED;
     _Rate_monotonic_Renew_deadline( the_period, owner, &lock_context );
-#endif
   }
 }
diff --git a/testsuites/smptests/sprmsched01/init.c b/testsuites/smptests/sprmsched01/init.c
index 6a2a9fe..727e604 100644
--- a/testsuites/smptests/sprmsched01/init.c
+++ b/testsuites/smptests/sprmsched01/init.c
@@ -1,33 +1,22 @@
 /**
- * @file sprmsched01/tasks.c
+ * @file sprmsched01/init.c
  *
- * @brief A heuristic example to demonstrate how the postponed jobs are handled.
+ * @brief A init task body for sprmsched01 example.
  *
- * Given two tasks with implicit deadline. To force deadline misses, we reverse
- * the rate-monotonic priority assignment and only execute the highest priority
- * task twice. In the original implementation, no matter how many periods are
- * expired, RMS manager only releases a job with a shifted deadline assignment
- * in the watchdog.
- *
- * In more general real-time task model, e.g., soft real-time task, the postponed
- * jobs are still required to be released when the task is available to execute.
  */

 /*
- * COPYRIGHT (c) 2016, Kuan-Hsun Chen.
- * TU Dortmund, Germany.
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
  *
- * The license and distribution terms for this file may be
- * found in the file LICENSE in this distribution or at
- * http://www.rtems.com/license/LICENSE.
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
  */

 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif

-#define CEILING_POS(X) ((X-(int)(X)) > 0 ? (int)(X+1) : (int)(X))
-#define CONFIGURE_INIT
 #include "system.h"
 #include <rtems/test.h>
 #include <rtems/status-checks.h>
diff --git a/testsuites/smptests/sprmsched01/system.h b/testsuites/smptests/sprmsched01/system.h
index 4ce8898..72e8eda 100644
--- a/testsuites/smptests/sprmsched01/system.h
+++ b/testsuites/smptests/sprmsched01/system.h
@@ -1,21 +1,21 @@
 /**
  * @file sprmsched01/system.h
  *
- * @brief Example header
+ * @brief sprmsched01 example header
  */

 /*
- *  COPYRIGHT (c) 2016, Kuan-Hsun Chen.
- *  TU Dortmund, Germany.
- *
  *  COPYRIGHT (c) 1989-2007.
  *  On-Line Applications Research Corporation (OAR).
  *
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
+ *
  *  The license and distribution terms for this file may be
  *  found in the file LICENSE in this distribution or at
  *  http://www.rtems.com/license/LICENSE.
  */

+
 #include <inttypes.h>
 #include <rtems.h>

@@ -39,10 +39,9 @@ rtems_task Task_2(

 extern rtems_id   Task_id[ 2 ];         /* array of task ids */
 extern rtems_name Task_name[ 2 ];       /* array of task names */
-extern uint32_t tick_per_second;
-extern int ntask;
-extern int testnumber;
-extern int experiment_flag;
+extern uint32_t tick_per_second;        /* time reference */
+extern int testnumber;                  /* stop condition */
+extern int experiment_flag;             /* flag for halting the experiment */

 /* configuration information */

diff --git a/testsuites/smptests/sprmsched01/tasks.c b/testsuites/smptests/sprmsched01/tasks.c
index 93ca241..6943343 100644
--- a/testsuites/smptests/sprmsched01/tasks.c
+++ b/testsuites/smptests/sprmsched01/tasks.c
@@ -14,8 +14,7 @@
  */

 /*
- *  COPYRIGHT (c) 2016, Kuan-Hsun Chen.
- *  TU Dortmund, Germany.
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
  *
  *  The license and distribution terms for this file may be
  *  found in the file LICENSE in this distribution or at
@@ -42,6 +41,9 @@
 #define task_1_normal_et	6000
 #define task_2_normal_et	1000

+/**
+ * @brief Task 1 body
+ */
 rtems_task Task_1(
   rtems_task_argument unused
 )
@@ -96,6 +98,9 @@ rtems_task Task_1(
 	}
 }

+/**
+ * @brief Task 2 body
+ */
 rtems_task Task_2(
   rtems_task_argument unused
 )
--
1.9.1


From 344632cceb3814b2d6cceffb45e444170978fac6 Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Fri, 5 Aug 2016 10:59:35 +0200
Subject: [PATCH 06/12] Fix a typo

---
 cpukit/rtems/src/ratemonperiod.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/cpukit/rtems/src/ratemonperiod.c b/cpukit/rtems/src/ratemonperiod.c
index 296d19b..124dd71 100644
--- a/cpukit/rtems/src/ratemonperiod.c
+++ b/cpukit/rtems/src/ratemonperiod.c
@@ -327,7 +327,7 @@ uint32_t rtems_rate_monotonic_Postponed_num(

   the_period = _Rate_monotonic_Get( period_id, &lock_context );
   _Assert(the_period != NULL);
-  uint32_t jobs = the_period->postponed_instances;
+  uint32_t jobs = the_period->postponed_jobs;
   owner = the_period->owner;
   _Rate_monotonic_Release( owner, &lock_context );
   return jobs;
--
1.9.1


From 28e09011fe49602d0c66b7d8ecdec21645675232 Mon Sep 17 00:00:00 2001
From: khchen <c0066c@gmail.com>
Date: Fri, 5 Aug 2016 11:49:12 +0200
Subject: [PATCH 07/12] Place example into wrong test folder

---
 c/src/lib/libbsp/bfin/acinclude.m4          |   4 +-
 c/src/lib/libbsp/powerpc/acinclude.m4       |   4 +-
 testsuites/smptests/Makefile.am             |   1 -
 testsuites/smptests/Makefile.am~            |  56 ++++++++++
 testsuites/smptests/configure.ac            |   1 -
 testsuites/smptests/sprmsched01/Makefile.am |  21 ----
 testsuites/smptests/sprmsched01/init.c      |  81 --------------
 testsuites/smptests/sprmsched01/system.h    | 130 ----------------------
 testsuites/smptests/sprmsched01/tasks.c     | 160 ----------------------------
 testsuites/sptests/Makefile.am              |   1 +
 testsuites/sptests/configure.ac             |   1 +
 11 files changed, 62 insertions(+), 398 deletions(-)
 create mode 100644 testsuites/smptests/Makefile.am~
 delete mode 100644 testsuites/smptests/sprmsched01/Makefile.am
 delete mode 100644 testsuites/smptests/sprmsched01/init.c
 delete mode 100644 testsuites/smptests/sprmsched01/system.h
 delete mode 100644 testsuites/smptests/sprmsched01/tasks.c

diff --git a/c/src/lib/libbsp/bfin/acinclude.m4 b/c/src/lib/libbsp/bfin/acinclude.m4
index ab6082e..828fd89 100644
--- a/c/src/lib/libbsp/bfin/acinclude.m4
+++ b/c/src/lib/libbsp/bfin/acinclude.m4
@@ -2,12 +2,12 @@
 AC_DEFUN([RTEMS_CHECK_BSPDIR],
 [
   case "$1" in
-  TLL6527M )
-    AC_CONFIG_SUBDIRS([TLL6527M]);;
   bf537Stamp )
     AC_CONFIG_SUBDIRS([bf537Stamp]);;
   eZKit533 )
     AC_CONFIG_SUBDIRS([eZKit533]);;
+  TLL6527M )
+    AC_CONFIG_SUBDIRS([TLL6527M]);;
   *)
     AC_MSG_ERROR([Invalid BSP]);;
   esac
diff --git a/c/src/lib/libbsp/powerpc/acinclude.m4 b/c/src/lib/libbsp/powerpc/acinclude.m4
index 4c83475..edc67b5 100644
--- a/c/src/lib/libbsp/powerpc/acinclude.m4
+++ b/c/src/lib/libbsp/powerpc/acinclude.m4
@@ -32,12 +32,12 @@ AC_DEFUN([RTEMS_CHECK_BSPDIR],
     AC_CONFIG_SUBDIRS([t32mppc]);;
   tqm8xx )
     AC_CONFIG_SUBDIRS([tqm8xx]);;
-  virtex )
-    AC_CONFIG_SUBDIRS([virtex]);;
   virtex4 )
     AC_CONFIG_SUBDIRS([virtex4]);;
   virtex5 )
     AC_CONFIG_SUBDIRS([virtex5]);;
+  virtex )
+    AC_CONFIG_SUBDIRS([virtex]);;
   *)
     AC_MSG_ERROR([Invalid BSP]);;
   esac
diff --git a/testsuites/smptests/Makefile.am b/testsuites/smptests/Makefile.am
index b943a4e..02d1dfc 100644
--- a/testsuites/smptests/Makefile.am
+++ b/testsuites/smptests/Makefile.am
@@ -43,7 +43,6 @@ SUBDIRS += smpswitchextension01
 SUBDIRS += smpthreadlife01
 SUBDIRS += smpunsupported01
 SUBDIRS += smpwakeafter01
-SUBDIRS += sprmsched01
 if HAS_POSIX
 SUBDIRS += smppsxaffinity01
 SUBDIRS += smppsxaffinity02
diff --git a/testsuites/smptests/Makefile.am~ b/testsuites/smptests/Makefile.am~
new file mode 100644
index 0000000..b943a4e
--- /dev/null
+++ b/testsuites/smptests/Makefile.am~
@@ -0,0 +1,56 @@
+ACLOCAL_AMFLAGS = -I ../aclocal
+
+SUBDIRS =
+if SMPTESTS
+SUBDIRS += smp01
+SUBDIRS += smp02
+SUBDIRS += smp03
+SUBDIRS += smp05
+SUBDIRS += smp07
+SUBDIRS += smp08
+SUBDIRS += smp09
+SUBDIRS += smpaffinity01
+SUBDIRS += smpatomic01
+SUBDIRS += smpcache01
+SUBDIRS += smpcapture01
+SUBDIRS += smpcapture02
+SUBDIRS += smpclock01
+SUBDIRS += smpfatal01
+SUBDIRS += smpfatal02
+SUBDIRS += smpfatal04
+SUBDIRS += smpfatal05
+SUBDIRS += smpfatal08
+SUBDIRS += smpipi01
+SUBDIRS += smpload01
+SUBDIRS += smplock01
+SUBDIRS += smpmigration01
+SUBDIRS += smpmigration02
+SUBDIRS += smpmrsp01
+SUBDIRS += smpmutex01
+SUBDIRS += smpmutex02
+SUBDIRS += smpschedaffinity01
+SUBDIRS += smpschedaffinity02
+SUBDIRS += smpschedaffinity03
+SUBDIRS += smpschedaffinity04
+SUBDIRS += smpschedaffinity05
+SUBDIRS += smpscheduler01
+SUBDIRS += smpscheduler02
+SUBDIRS += smpscheduler03
+SUBDIRS += smpschedsem01
+SUBDIRS += smpsignal01
+SUBDIRS += smpstrongapa01
+SUBDIRS += smpswitchextension01
+SUBDIRS += smpthreadlife01
+SUBDIRS += smpunsupported01
+SUBDIRS += smpwakeafter01
+SUBDIRS += sprmsched01
+if HAS_POSIX
+SUBDIRS += smppsxaffinity01
+SUBDIRS += smppsxaffinity02
+SUBDIRS += smppsxmutex01
+SUBDIRS += smppsxsignal01
+endif
+endif
+
+include $(top_srcdir)/../automake/subdirs.am
+include $(top_srcdir)/../automake/local.am
diff --git a/testsuites/smptests/configure.ac b/testsuites/smptests/configure.ac
index a249729..8c8476f 100644
--- a/testsuites/smptests/configure.ac
+++ b/testsuites/smptests/configure.ac
@@ -102,6 +102,5 @@ smpswitchextension01/Makefile
 smpthreadlife01/Makefile
 smpunsupported01/Makefile
 smpwakeafter01/Makefile
-sprmsched01/Makefile
 ])
 AC_OUTPUT
diff --git a/testsuites/smptests/sprmsched01/Makefile.am b/testsuites/smptests/sprmsched01/Makefile.am
deleted file mode 100644
index f21fdb7..0000000
--- a/testsuites/smptests/sprmsched01/Makefile.am
+++ /dev/null
@@ -1,21 +0,0 @@
-
-rtems_tests_PROGRAMS = sprmsched01
-sprmsched01_SOURCES = system.h \
-	init.c \
-	tasks.c
-
-dist_rtems_tests_DATA = sprmsched01.scn sprmsched01.doc
-
-include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
-include $(top_srcdir)/../automake/compile.am
-include $(top_srcdir)/../automake/leaf.am
-
-
-LINK_OBJS = $(deadlinemiss_OBJECTS)
-LINK_LIBS = $(deadlinemiss_LDLIBS) -lm
-
-sprmsched01$(EXEEXT): $(sprmsched01_OBJECTS) $(sprmsched01_DEPENDENCIES)
-	@rm -f sprmsched01$(EXEEXT)
-	$(make-exe)
-
-include $(top_srcdir)/../automake/local.am
diff --git a/testsuites/smptests/sprmsched01/init.c b/testsuites/smptests/sprmsched01/init.c
deleted file mode 100644
index 727e604..0000000
--- a/testsuites/smptests/sprmsched01/init.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/**
- * @file sprmsched01/init.c
- *
- * @brief A init task body for sprmsched01 example.
- *
- */
-
-/*
- *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
- *
- *  The license and distribution terms for this file may be
- *  found in the file LICENSE in this distribution or at
- *  http://www.rtems.com/license/LICENSE.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "system.h"
-#include <rtems/test.h>
-#include <rtems/status-checks.h>
-
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-/* Global variables */
-int experiment_flag = 0;
-int testnumber = 15;
-rtems_id Task_id[ 2 ];
-rtems_name Task_name[ 2 ];
-uint32_t tick_per_second;
-
-rtems_task Init(
-	rtems_task_argument argument
-)
-{
-  rtems_status_code status;
-
-  tick_per_second = rtems_clock_get_ticks_per_second();
-  printf("\nTicks per second in your system: %" PRIu32 "\n", tick_per_second);
-
-  Task_name[ 1 ] = rtems_build_name( 'T', 'A', '1', ' ' );
-  Task_name[ 2 ] = rtems_build_name( 'T', 'A', '2', ' ' );
-
-  /* Create two tasks */
-  status = rtems_task_create(
-    Task_name[ 1 ], 2, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
-    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 1 ]
-  );
-  if ( status != RTEMS_SUCCESSFUL) {
-    printf( "rtems_task_create 1 failed with status of %d.\n", status );
-    exit( 1 );
-  }
-
-  status = rtems_task_create(
-    Task_name[ 2 ], 5, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
-    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 2 ]
-  );
-  if ( status != RTEMS_SUCCESSFUL) {
-    printf( "rtems_task_create 2 failed with status of %d.\n", status );
-    exit( 1 );
-  }
-
-  /* After creating the periods for tasks, start to run them sequencially. */
-
-  experiment_flag = 1;
-  status = rtems_task_start( Task_id[ 1 ], Task_1, 1);
-  if ( status != RTEMS_SUCCESSFUL) {
-    printf( "rtems_task_start 1 failed with status of %d.\n", status );
-    exit( 1 );
-  }
-  status = rtems_task_start( Task_id[ 2 ], Task_2, 1);
-  if ( status != RTEMS_SUCCESSFUL) {
-    printf( "rtems_task_start 2 failed with status of %d.\n", status );
-    exit( 1 );
-  }
-
-  status = rtems_task_delete( RTEMS_SELF );
-}
diff --git a/testsuites/smptests/sprmsched01/system.h b/testsuites/smptests/sprmsched01/system.h
deleted file mode 100644
index 72e8eda..0000000
--- a/testsuites/smptests/sprmsched01/system.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * @file sprmsched01/system.h
- *
- * @brief sprmsched01 example header
- */
-
-/*
- *  COPYRIGHT (c) 1989-2007.
- *  On-Line Applications Research Corporation (OAR).
- *
- *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
- *
- *  The license and distribution terms for this file may be
- *  found in the file LICENSE in this distribution or at
- *  http://www.rtems.com/license/LICENSE.
- */
-
-
-#include <inttypes.h>
-#include <rtems.h>
-
-/* function prototypes */
-
-rtems_task Init(
-  rtems_task_argument argument
-);
-
-rtems_task Task_1(
-  rtems_task_argument argument
-);
-
-rtems_task Task_2(
-  rtems_task_argument argument
-);
-
-/*
- *  Keep the names and IDs in global variables so another task can use them.
- */
-
-extern rtems_id   Task_id[ 2 ];         /* array of task ids */
-extern rtems_name Task_name[ 2 ];       /* array of task names */
-extern uint32_t tick_per_second;        /* time reference */
-extern int testnumber;                  /* stop condition */
-extern int experiment_flag;             /* flag for halting the experiment */
-
-/* configuration information */
-
-#include <bsp.h> /* for device driver prototypes */
-
-#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
-#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
-#define CONFIGURE_MICROSECONDS_PER_TICK     1000   // NB: 10 and lower gives system failure for erc32 simulator
-#define CONFIGURE_MAXIMUM_TASKS             3
-#define CONFIGURE_MAXIMUM_SEMAPHORES        1
-#define CONFIGURE_MAXIMUM_PRIORITY          15
-#define CONFIGURE_EXTRA_TASK_STACKS         (20 * RTEMS_MINIMUM_STACK_SIZE)
-#define CONFIGURE_MAXIMUM_PERIODS           3
-
-#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
-
-#include <rtems/confdefs.h>
-
-/*
- *  Macro to hide the ugliness of printing the time.
- */
-
-#define print_time(_s1, _tb, _s2) \
-  do { \
-    printf( "%s%02" PRIu32 ":%02" PRIu32 ":%02" PRIu32 \
-       "   %02" PRIu32 "/%02" PRIu32 "/%04" PRIu32 "%s", \
-       _s1, (_tb)->hour, (_tb)->minute, (_tb)->second, \
-       (_tb)->month, (_tb)->day, (_tb)->year, _s2 ); \
-    fflush(stdout); \
-  } while ( 0 )
-
-/*
- *  Macro to print an task name that is composed of ASCII characters.
- *
- */
-
-#define put_name( _name, _crlf ) \
-  do { \
-    uint32_t c0, c1, c2, c3; \
-    \
-    c0 = ((_name) >> 24) & 0xff; \
-    c1 = ((_name) >> 16) & 0xff; \
-    c2 = ((_name) >> 8) & 0xff; \
-    c3 = (_name) & 0xff; \
-    putchar( (char)c0 ); \
-    if ( c1 ) putchar( (char)c1 ); \
-    if ( c2 ) putchar( (char)c2 ); \
-    if ( c3 ) putchar( (char)c3 ); \
-    if ( (_crlf) ) \
-      putchar( '\n' ); \
-  } while (0)
-
-/*
- *  Macro to loop/simulate the execution time.
- */
-
-
-#define LOOP(_et, taskID){ \
-  \
-  int start = 0; \
-  int now = 0; \
-  start = rtems_clock_get_ticks_since_boot();\
-  while(1){\
-	\
-    now = rtems_clock_get_ticks_since_boot();\
-	  if(now-start >= _et){\
-	  	break;\
-    }\
- }\
-}
-
-/*
- *  This allows us to view the "Test_task" instantiations as a set
- *  of numbered tasks by eliminating the number of application
- *  tasks created.
- *
- *  In reality, this is too complex for the purposes of this
- *  example.  It would have been easier to pass a task argument. :)
- *  But it shows how rtems_id's can sometimes be used.
- */
-
-#define task_number( tid ) \
-  ( rtems_get_index( tid ) - \
-     rtems_configuration_get_rtems_api_configuration()->number_of_initialization_tasks )
-
-/* end of include file */
diff --git a/testsuites/smptests/sprmsched01/tasks.c b/testsuites/smptests/sprmsched01/tasks.c
deleted file mode 100644
index 6943343..0000000
--- a/testsuites/smptests/sprmsched01/tasks.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/**
- * @file sprmsched01/tasks.c
- *
- * @brief A heuristic example to demonstrate how the postponed jobs are handled.
- *
- * Given two tasks with implicit deadline. To force deadline misses, we reverse
- * the rate-monotonic priority assignment and only execute the highest priority
- * task twice. In the original implementation, no matter how many periods are
- * expired, RMS manager only releases a job with a shifted deadline assignment
- * in the watchdog.
- *
- * In more general real-time task model, e.g., soft real-time task, the postponed
- * jobs are still required to be released when the task is available to execute.
- */
-
-/*
- *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
- *
- *  The license and distribution terms for this file may be
- *  found in the file LICENSE in this distribution or at
- *  http://www.rtems.com/license/LICENSE.
- */
-
-#include "system.h"
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-/* CPU usage and Rate monotonic manger statistics */
-#include "rtems/cpuuse.h"
-
-/* Periods for the various tasks [ticks] */
-#define PERIOD_TASK_1          10000
-#define PERIOD_TASK_2          2000
-
-/* Task Id */
-#define ID_TASK_1           0
-#define ID_TASK_2          	1
-
-/* Execution time for each task [ticks] */
-#define task_1_normal_et	6000
-#define task_2_normal_et	1000
-
-/**
- * @brief Task 1 body
- */
-rtems_task Task_1(
-  rtems_task_argument unused
-)
-{
-  rtems_status_code status;
-  rtems_name        period_name;
-  rtems_id          RM_period;
-  rtems_id 			selfid=rtems_task_self();
-  double            start, end;
-  int		    	tsk_counter = 0;
-  int		    	startTick = 0;
-
-  /*create period*/
-  period_name = rtems_build_name( 'P', 'E', 'R', '1' );
-  status = rtems_rate_monotonic_create( period_name, &RM_period );
-  if( RTEMS_SUCCESSFUL != status ) {
-    printf("RM failed with status: %d\n", status);
-    exit(1);
-  }
-
-	while( 1 ) {
-		status = rtems_rate_monotonic_period( RM_period,PERIOD_TASK_1);
-
-		if(tsk_counter == 2){
-
-				status = rtems_rate_monotonic_delete(RM_period);
-				if(status != RTEMS_SUCCESSFUL){
-					printf("BUG: Cannot delete the period 1\n");
-					exit(1);
-				}
-
-				status=rtems_task_delete(selfid);
-				if(status != RTEMS_SUCCESSFUL){
-					printf("BUG: Cannot delete the task 1\n");
-					exit(1);
-				}
-
-		}else{
-
-			startTick = rtems_clock_get_ticks_since_boot();
-			start = startTick  / (double)tick_per_second;
-
-			printf("Task 1 starts current second %.6f.\n", start);
-
-			LOOP(task_1_normal_et,task_id);
-
-			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
-
-			printf("					Task 1 ends at current second  %.6f .\n", end);
- 			tsk_counter += 1;
-		}
-	}
-}
-
-/**
- * @brief Task 2 body
- */
-rtems_task Task_2(
-  rtems_task_argument unused
-)
-{
-  rtems_id selfid=rtems_task_self();
-  rtems_status_code status;
-  rtems_name        period_name;
-  rtems_id          RM_period;
-  double 	        start, end;
-  int		        tsk_counter = 0;
-  int		        startTick = 0;
-
-  /*create period*/
-
-  period_name = rtems_build_name( 'P', 'E', 'R', '2' );
-  status = rtems_rate_monotonic_create( period_name, &RM_period );
-  if( RTEMS_SUCCESSFUL != status ) {
-    printf("RM failed with status: %d\n", status);
-    exit(1);
-  }
-
-	while( 1 ) {
-
-		/*this part for release offset*/
-		status = rtems_rate_monotonic_period( RM_period, PERIOD_TASK_2);
-
-		if(experiment_flag ==0){
-			status = rtems_rate_monotonic_delete(RM_period);
-			if(status != RTEMS_SUCCESSFUL){
-				printf("BUG: Cannot delete the period 2\n");
-				exit(1);
-			}
-			/* The example is finished */
-			exit(1);
-		}else{
-
-			startTick = rtems_clock_get_ticks_since_boot();
-			start = startTick  / (double)tick_per_second;
-
-			printf("Task 2 starts at current second %.6f.\n", start);
-
-			LOOP(task_2_normal_et,task_id);
-
-			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
-
-			printf("					%d Task 2 ends at current second %.6f.\n", tsk_counter+1, end);
-
-			tsk_counter += 1;
-
-			if(tsk_counter == testnumber){
-			  rtems_rate_monotonic_report_statistics();
-			  experiment_flag=0;
-			}
-		}
-	}
-}
-
diff --git a/testsuites/sptests/Makefile.am b/testsuites/sptests/Makefile.am
index 20ea9d5..d432747 100644
--- a/testsuites/sptests/Makefile.am
+++ b/testsuites/sptests/Makefile.am
@@ -36,6 +36,7 @@ _SUBDIRS = \
 _SUBDIRS += spmutex01
 _SUBDIRS += spextensions01
 _SUBDIRS += spsysinit01
+_SUBDIRS += sprmsched01
 if HAS_SMP
 else
 _SUBDIRS += sp29
diff --git a/testsuites/sptests/configure.ac b/testsuites/sptests/configure.ac
index c96edd3..888cdd5 100644
--- a/testsuites/sptests/configure.ac
+++ b/testsuites/sptests/configure.ac
@@ -255,5 +255,6 @@ sptimer_err02/Makefile
 spcpuset01/Makefile
 spregion_err01/Makefile
 sppartition_err01/Makefile
+sprmsched01/Makefile
 ])
 AC_OUTPUT
--
1.9.1


From c6c715377790dba90445590812667ad99661f626 Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Fri, 5 Aug 2016 13:46:21 +0200
Subject: [PATCH 08/12] Correct place

---
 testsuites/sptests/sprmsched01/init.c   |  81 ++++++++++++++++
 testsuites/sptests/sprmsched01/system.h | 130 ++++++++++++++++++++++++++
 testsuites/sptests/sprmsched01/tasks.c  | 160 ++++++++++++++++++++++++++++++++
 3 files changed, 371 insertions(+)
 create mode 100644 testsuites/sptests/sprmsched01/init.c
 create mode 100644 testsuites/sptests/sprmsched01/system.h
 create mode 100644 testsuites/sptests/sprmsched01/tasks.c

diff --git a/testsuites/sptests/sprmsched01/init.c b/testsuites/sptests/sprmsched01/init.c
new file mode 100644
index 0000000..727e604
--- /dev/null
+++ b/testsuites/sptests/sprmsched01/init.c
@@ -0,0 +1,81 @@
+/**
+ * @file sprmsched01/init.c
+ *
+ * @brief A init task body for sprmsched01 example.
+ *
+ */
+
+/*
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "system.h"
+#include <rtems/test.h>
+#include <rtems/status-checks.h>
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+/* Global variables */
+int experiment_flag = 0;
+int testnumber = 15;
+rtems_id Task_id[ 2 ];
+rtems_name Task_name[ 2 ];
+uint32_t tick_per_second;
+
+rtems_task Init(
+	rtems_task_argument argument
+)
+{
+  rtems_status_code status;
+
+  tick_per_second = rtems_clock_get_ticks_per_second();
+  printf("\nTicks per second in your system: %" PRIu32 "\n", tick_per_second);
+
+  Task_name[ 1 ] = rtems_build_name( 'T', 'A', '1', ' ' );
+  Task_name[ 2 ] = rtems_build_name( 'T', 'A', '2', ' ' );
+
+  /* Create two tasks */
+  status = rtems_task_create(
+    Task_name[ 1 ], 2, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
+    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 1 ]
+  );
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_create 1 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+  status = rtems_task_create(
+    Task_name[ 2 ], 5, RTEMS_MINIMUM_STACK_SIZE * 2, RTEMS_DEFAULT_MODES,
+    RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ 2 ]
+  );
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_create 2 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+  /* After creating the periods for tasks, start to run them sequencially. */
+
+  experiment_flag = 1;
+  status = rtems_task_start( Task_id[ 1 ], Task_1, 1);
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_start 1 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+  status = rtems_task_start( Task_id[ 2 ], Task_2, 1);
+  if ( status != RTEMS_SUCCESSFUL) {
+    printf( "rtems_task_start 2 failed with status of %d.\n", status );
+    exit( 1 );
+  }
+
+  status = rtems_task_delete( RTEMS_SELF );
+}
diff --git a/testsuites/sptests/sprmsched01/system.h b/testsuites/sptests/sprmsched01/system.h
new file mode 100644
index 0000000..72e8eda
--- /dev/null
+++ b/testsuites/sptests/sprmsched01/system.h
@@ -0,0 +1,130 @@
+/**
+ * @file sprmsched01/system.h
+ *
+ * @brief sprmsched01 example header
+ */
+
+/*
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ */
+
+
+#include <inttypes.h>
+#include <rtems.h>
+
+/* function prototypes */
+
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+rtems_task Task_1(
+  rtems_task_argument argument
+);
+
+rtems_task Task_2(
+  rtems_task_argument argument
+);
+
+/*
+ *  Keep the names and IDs in global variables so another task can use them.
+ */
+
+extern rtems_id   Task_id[ 2 ];         /* array of task ids */
+extern rtems_name Task_name[ 2 ];       /* array of task names */
+extern uint32_t tick_per_second;        /* time reference */
+extern int testnumber;                  /* stop condition */
+extern int experiment_flag;             /* flag for halting the experiment */
+
+/* configuration information */
+
+#include <bsp.h> /* for device driver prototypes */
+
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_MICROSECONDS_PER_TICK     1000   // NB: 10 and lower gives system failure for erc32 simulator
+#define CONFIGURE_MAXIMUM_TASKS             3
+#define CONFIGURE_MAXIMUM_SEMAPHORES        1
+#define CONFIGURE_MAXIMUM_PRIORITY          15
+#define CONFIGURE_EXTRA_TASK_STACKS         (20 * RTEMS_MINIMUM_STACK_SIZE)
+#define CONFIGURE_MAXIMUM_PERIODS           3
+
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+
+#include <rtems/confdefs.h>
+
+/*
+ *  Macro to hide the ugliness of printing the time.
+ */
+
+#define print_time(_s1, _tb, _s2) \
+  do { \
+    printf( "%s%02" PRIu32 ":%02" PRIu32 ":%02" PRIu32 \
+       "   %02" PRIu32 "/%02" PRIu32 "/%04" PRIu32 "%s", \
+       _s1, (_tb)->hour, (_tb)->minute, (_tb)->second, \
+       (_tb)->month, (_tb)->day, (_tb)->year, _s2 ); \
+    fflush(stdout); \
+  } while ( 0 )
+
+/*
+ *  Macro to print an task name that is composed of ASCII characters.
+ *
+ */
+
+#define put_name( _name, _crlf ) \
+  do { \
+    uint32_t c0, c1, c2, c3; \
+    \
+    c0 = ((_name) >> 24) & 0xff; \
+    c1 = ((_name) >> 16) & 0xff; \
+    c2 = ((_name) >> 8) & 0xff; \
+    c3 = (_name) & 0xff; \
+    putchar( (char)c0 ); \
+    if ( c1 ) putchar( (char)c1 ); \
+    if ( c2 ) putchar( (char)c2 ); \
+    if ( c3 ) putchar( (char)c3 ); \
+    if ( (_crlf) ) \
+      putchar( '\n' ); \
+  } while (0)
+
+/*
+ *  Macro to loop/simulate the execution time.
+ */
+
+
+#define LOOP(_et, taskID){ \
+  \
+  int start = 0; \
+  int now = 0; \
+  start = rtems_clock_get_ticks_since_boot();\
+  while(1){\
+	\
+    now = rtems_clock_get_ticks_since_boot();\
+	  if(now-start >= _et){\
+	  	break;\
+    }\
+ }\
+}
+
+/*
+ *  This allows us to view the "Test_task" instantiations as a set
+ *  of numbered tasks by eliminating the number of application
+ *  tasks created.
+ *
+ *  In reality, this is too complex for the purposes of this
+ *  example.  It would have been easier to pass a task argument. :)
+ *  But it shows how rtems_id's can sometimes be used.
+ */
+
+#define task_number( tid ) \
+  ( rtems_get_index( tid ) - \
+     rtems_configuration_get_rtems_api_configuration()->number_of_initialization_tasks )
+
+/* end of include file */
diff --git a/testsuites/sptests/sprmsched01/tasks.c b/testsuites/sptests/sprmsched01/tasks.c
new file mode 100644
index 0000000..6943343
--- /dev/null
+++ b/testsuites/sptests/sprmsched01/tasks.c
@@ -0,0 +1,160 @@
+/**
+ * @file sprmsched01/tasks.c
+ *
+ * @brief A heuristic example to demonstrate how the postponed jobs are handled.
+ *
+ * Given two tasks with implicit deadline. To force deadline misses, we reverse
+ * the rate-monotonic priority assignment and only execute the highest priority
+ * task twice. In the original implementation, no matter how many periods are
+ * expired, RMS manager only releases a job with a shifted deadline assignment
+ * in the watchdog.
+ *
+ * In more general real-time task model, e.g., soft real-time task, the postponed
+ * jobs are still required to be released when the task is available to execute.
+ */
+
+/*
+ *  COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ */
+
+#include "system.h"
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+/* CPU usage and Rate monotonic manger statistics */
+#include "rtems/cpuuse.h"
+
+/* Periods for the various tasks [ticks] */
+#define PERIOD_TASK_1          10000
+#define PERIOD_TASK_2          2000
+
+/* Task Id */
+#define ID_TASK_1           0
+#define ID_TASK_2          	1
+
+/* Execution time for each task [ticks] */
+#define task_1_normal_et	6000
+#define task_2_normal_et	1000
+
+/**
+ * @brief Task 1 body
+ */
+rtems_task Task_1(
+  rtems_task_argument unused
+)
+{
+  rtems_status_code status;
+  rtems_name        period_name;
+  rtems_id          RM_period;
+  rtems_id 			selfid=rtems_task_self();
+  double            start, end;
+  int		    	tsk_counter = 0;
+  int		    	startTick = 0;
+
+  /*create period*/
+  period_name = rtems_build_name( 'P', 'E', 'R', '1' );
+  status = rtems_rate_monotonic_create( period_name, &RM_period );
+  if( RTEMS_SUCCESSFUL != status ) {
+    printf("RM failed with status: %d\n", status);
+    exit(1);
+  }
+
+	while( 1 ) {
+		status = rtems_rate_monotonic_period( RM_period,PERIOD_TASK_1);
+
+		if(tsk_counter == 2){
+
+				status = rtems_rate_monotonic_delete(RM_period);
+				if(status != RTEMS_SUCCESSFUL){
+					printf("BUG: Cannot delete the period 1\n");
+					exit(1);
+				}
+
+				status=rtems_task_delete(selfid);
+				if(status != RTEMS_SUCCESSFUL){
+					printf("BUG: Cannot delete the task 1\n");
+					exit(1);
+				}
+
+		}else{
+
+			startTick = rtems_clock_get_ticks_since_boot();
+			start = startTick  / (double)tick_per_second;
+
+			printf("Task 1 starts current second %.6f.\n", start);
+
+			LOOP(task_1_normal_et,task_id);
+
+			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
+
+			printf("					Task 1 ends at current second  %.6f .\n", end);
+ 			tsk_counter += 1;
+		}
+	}
+}
+
+/**
+ * @brief Task 2 body
+ */
+rtems_task Task_2(
+  rtems_task_argument unused
+)
+{
+  rtems_id selfid=rtems_task_self();
+  rtems_status_code status;
+  rtems_name        period_name;
+  rtems_id          RM_period;
+  double 	        start, end;
+  int		        tsk_counter = 0;
+  int		        startTick = 0;
+
+  /*create period*/
+
+  period_name = rtems_build_name( 'P', 'E', 'R', '2' );
+  status = rtems_rate_monotonic_create( period_name, &RM_period );
+  if( RTEMS_SUCCESSFUL != status ) {
+    printf("RM failed with status: %d\n", status);
+    exit(1);
+  }
+
+	while( 1 ) {
+
+		/*this part for release offset*/
+		status = rtems_rate_monotonic_period( RM_period, PERIOD_TASK_2);
+
+		if(experiment_flag ==0){
+			status = rtems_rate_monotonic_delete(RM_period);
+			if(status != RTEMS_SUCCESSFUL){
+				printf("BUG: Cannot delete the period 2\n");
+				exit(1);
+			}
+			/* The example is finished */
+			exit(1);
+		}else{
+
+			startTick = rtems_clock_get_ticks_since_boot();
+			start = startTick  / (double)tick_per_second;
+
+			printf("Task 2 starts at current second %.6f.\n", start);
+
+			LOOP(task_2_normal_et,task_id);
+
+			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
+
+			printf("					%d Task 2 ends at current second %.6f.\n", tsk_counter+1, end);
+
+			tsk_counter += 1;
+
+			if(tsk_counter == testnumber){
+			  rtems_rate_monotonic_report_statistics();
+			  experiment_flag=0;
+			}
+		}
+	}
+}
+
--
1.9.1


From aef2a640e9800dea4aa6a07283dce9494c25c79a Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Fri, 5 Aug 2016 13:49:12 +0200
Subject: [PATCH 09/12] Remove unused variable

---
 testsuites/sptests/sprmsched01/tasks.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/testsuites/sptests/sprmsched01/tasks.c b/testsuites/sptests/sprmsched01/tasks.c
index 6943343..44591e2 100644
--- a/testsuites/sptests/sprmsched01/tasks.c
+++ b/testsuites/sptests/sprmsched01/tasks.c
@@ -105,7 +105,6 @@ rtems_task Task_2(
   rtems_task_argument unused
 )
 {
-  rtems_id selfid=rtems_task_self();
   rtems_status_code status;
   rtems_name        period_name;
   rtems_id          RM_period;
--
1.9.1


From 41f65ed1c05004e9a6f9c7283bf2eb01c54c2aa2 Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Fri, 5 Aug 2016 16:20:52 +0200
Subject: [PATCH 10/12] Define the correct Marcos

---
 testsuites/smptests/sprmsched01/Makefile.am | 21 ++++++++++
 testsuites/sptests/sprmsched01/Makefile.am  | 21 ++++++++++
 testsuites/sptests/sprmsched01/init.c       | 27 ++++++-------
 testsuites/sptests/sprmsched01/system.h     | 61 ++++-------------------------
 testsuites/sptests/sprmsched01/tasks.c      | 20 ++++++----
 5 files changed, 74 insertions(+), 76 deletions(-)
 create mode 100644 testsuites/smptests/sprmsched01/Makefile.am
 create mode 100644 testsuites/sptests/sprmsched01/Makefile.am

diff --git a/testsuites/smptests/sprmsched01/Makefile.am b/testsuites/smptests/sprmsched01/Makefile.am
new file mode 100644
index 0000000..f21fdb7
--- /dev/null
+++ b/testsuites/smptests/sprmsched01/Makefile.am
@@ -0,0 +1,21 @@
+
+rtems_tests_PROGRAMS = sprmsched01
+sprmsched01_SOURCES = system.h \
+	init.c \
+	tasks.c
+
+dist_rtems_tests_DATA = sprmsched01.scn sprmsched01.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+
+LINK_OBJS = $(deadlinemiss_OBJECTS)
+LINK_LIBS = $(deadlinemiss_LDLIBS) -lm
+
+sprmsched01$(EXEEXT): $(sprmsched01_OBJECTS) $(sprmsched01_DEPENDENCIES)
+	@rm -f sprmsched01$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff --git a/testsuites/sptests/sprmsched01/Makefile.am b/testsuites/sptests/sprmsched01/Makefile.am
new file mode 100644
index 0000000..f837b52
--- /dev/null
+++ b/testsuites/sptests/sprmsched01/Makefile.am
@@ -0,0 +1,21 @@
+
+rtems_tests_PROGRAMS = sprmsched01
+sprmsched01_SOURCES = init.c tasks.c system.h
+
+dist_rtems_tests_DATA = sprmsched01.scn
+dist_rtems_tests_DATA += sprmsched01.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+AM_CPPFLAGS += -I$(top_srcdir)/../support/include
+
+LINK_OBJS = $(sprmsched01_OBJECTS)
+LINK_LIBS = $(sprmsched01_LDLIBS)
+
+sprmsched01$(EXEEXT): $(sprmsched01_OBJECTS) $(sprmsched01_DEPENDENCIES)
+	@rm -f sprmsched01$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff --git a/testsuites/sptests/sprmsched01/init.c b/testsuites/sptests/sprmsched01/init.c
index 727e604..48d6d0f 100644
--- a/testsuites/sptests/sprmsched01/init.c
+++ b/testsuites/sptests/sprmsched01/init.c
@@ -17,25 +17,20 @@
 #include "config.h"
 #endif

+#define CONFIGURE_INIT
 #include "system.h"
-#include <rtems/test.h>
-#include <rtems/status-checks.h>

-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
+#include <rtems/rtems/tasksimpl.h>

-/* Global variables */
-int experiment_flag = 0;
-int testnumber = 15;
-rtems_id Task_id[ 2 ];
-rtems_name Task_name[ 2 ];
-uint32_t tick_per_second;
+const char rtems_test_name[] = "Rate Monotonic 01";

+
+#if 1
 rtems_task Init(
 	rtems_task_argument argument
 )
 {
+  TEST_BEGIN();
   rtems_status_code status;

   tick_per_second = rtems_clock_get_ticks_per_second();
@@ -51,7 +46,7 @@ rtems_task Init(
   );
   if ( status != RTEMS_SUCCESSFUL) {
     printf( "rtems_task_create 1 failed with status of %d.\n", status );
-    exit( 1 );
+    rtems_test_exit(0);
   }

   status = rtems_task_create(
@@ -60,7 +55,7 @@ rtems_task Init(
   );
   if ( status != RTEMS_SUCCESSFUL) {
     printf( "rtems_task_create 2 failed with status of %d.\n", status );
-    exit( 1 );
+    rtems_test_exit(0);
   }

   /* After creating the periods for tasks, start to run them sequencially. */
@@ -69,13 +64,15 @@ rtems_task Init(
   status = rtems_task_start( Task_id[ 1 ], Task_1, 1);
   if ( status != RTEMS_SUCCESSFUL) {
     printf( "rtems_task_start 1 failed with status of %d.\n", status );
-    exit( 1 );
+    rtems_test_exit(0);
   }
   status = rtems_task_start( Task_id[ 2 ], Task_2, 1);
   if ( status != RTEMS_SUCCESSFUL) {
     printf( "rtems_task_start 2 failed with status of %d.\n", status );
-    exit( 1 );
+    rtems_test_exit(0);
   }

   status = rtems_task_delete( RTEMS_SELF );
 }
+
+#endif
diff --git a/testsuites/sptests/sprmsched01/system.h b/testsuites/sptests/sprmsched01/system.h
index 72e8eda..b99b74a 100644
--- a/testsuites/sptests/sprmsched01/system.h
+++ b/testsuites/sptests/sprmsched01/system.h
@@ -19,6 +19,8 @@
 #include <inttypes.h>
 #include <rtems.h>

+#include <tmacros.h>
+
 /* function prototypes */

 rtems_task Init(
@@ -37,11 +39,11 @@ rtems_task Task_2(
  *  Keep the names and IDs in global variables so another task can use them.
  */

-extern rtems_id   Task_id[ 2 ];         /* array of task ids */
-extern rtems_name Task_name[ 2 ];       /* array of task names */
-extern uint32_t tick_per_second;        /* time reference */
-extern int testnumber;                  /* stop condition */
-extern int experiment_flag;             /* flag for halting the experiment */
+TEST_EXTERN rtems_id   Task_id[ 2 ];         /* array of task ids */
+TEST_EXTERN rtems_name Task_name[ 2 ];       /* array of task names */
+TEST_EXTERN uint32_t tick_per_second;        /* time reference */
+TEST_EXTERN int testnumber;                  /* stop condition */
+TEST_EXTERN int experiment_flag;             /* flag for halting the experiment */

 /* configuration information */

@@ -61,40 +63,6 @@ extern int experiment_flag;             /* flag for halting the experiment */
 #include <rtems/confdefs.h>

 /*
- *  Macro to hide the ugliness of printing the time.
- */
-
-#define print_time(_s1, _tb, _s2) \
-  do { \
-    printf( "%s%02" PRIu32 ":%02" PRIu32 ":%02" PRIu32 \
-       "   %02" PRIu32 "/%02" PRIu32 "/%04" PRIu32 "%s", \
-       _s1, (_tb)->hour, (_tb)->minute, (_tb)->second, \
-       (_tb)->month, (_tb)->day, (_tb)->year, _s2 ); \
-    fflush(stdout); \
-  } while ( 0 )
-
-/*
- *  Macro to print an task name that is composed of ASCII characters.
- *
- */
-
-#define put_name( _name, _crlf ) \
-  do { \
-    uint32_t c0, c1, c2, c3; \
-    \
-    c0 = ((_name) >> 24) & 0xff; \
-    c1 = ((_name) >> 16) & 0xff; \
-    c2 = ((_name) >> 8) & 0xff; \
-    c3 = (_name) & 0xff; \
-    putchar( (char)c0 ); \
-    if ( c1 ) putchar( (char)c1 ); \
-    if ( c2 ) putchar( (char)c2 ); \
-    if ( c3 ) putchar( (char)c3 ); \
-    if ( (_crlf) ) \
-      putchar( '\n' ); \
-  } while (0)
-
-/*
  *  Macro to loop/simulate the execution time.
  */

@@ -112,19 +80,4 @@ extern int experiment_flag;             /* flag for halting the experiment */
     }\
  }\
 }
-
-/*
- *  This allows us to view the "Test_task" instantiations as a set
- *  of numbered tasks by eliminating the number of application
- *  tasks created.
- *
- *  In reality, this is too complex for the purposes of this
- *  example.  It would have been easier to pass a task argument. :)
- *  But it shows how rtems_id's can sometimes be used.
- */
-
-#define task_number( tid ) \
-  ( rtems_get_index( tid ) - \
-     rtems_configuration_get_rtems_api_configuration()->number_of_initialization_tasks )
-
 /* end of include file */
diff --git a/testsuites/sptests/sprmsched01/tasks.c b/testsuites/sptests/sprmsched01/tasks.c
index 44591e2..3eb488f 100644
--- a/testsuites/sptests/sprmsched01/tasks.c
+++ b/testsuites/sptests/sprmsched01/tasks.c
@@ -21,10 +21,15 @@
  *  http://www.rtems.com/license/LICENSE.
  */

+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "system.h"
-#include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <rtems.h>
+#include <rtems/rtems/tasksimpl.h>

 /* CPU usage and Rate monotonic manger statistics */
 #include "rtems/cpuuse.h"
@@ -61,7 +66,7 @@ rtems_task Task_1(
   status = rtems_rate_monotonic_create( period_name, &RM_period );
   if( RTEMS_SUCCESSFUL != status ) {
     printf("RM failed with status: %d\n", status);
-    exit(1);
+    rtems_test_exit(0);
   }

 	while( 1 ) {
@@ -72,13 +77,13 @@ rtems_task Task_1(
 				status = rtems_rate_monotonic_delete(RM_period);
 				if(status != RTEMS_SUCCESSFUL){
 					printf("BUG: Cannot delete the period 1\n");
-					exit(1);
+          rtems_test_exit(0);
 				}

 				status=rtems_task_delete(selfid);
 				if(status != RTEMS_SUCCESSFUL){
 					printf("BUG: Cannot delete the task 1\n");
-					exit(1);
+          rtems_test_exit(0);
 				}

 		}else{
@@ -118,7 +123,7 @@ rtems_task Task_2(
   status = rtems_rate_monotonic_create( period_name, &RM_period );
   if( RTEMS_SUCCESSFUL != status ) {
     printf("RM failed with status: %d\n", status);
-    exit(1);
+    exit( 0 );
   }

 	while( 1 ) {
@@ -130,10 +135,11 @@ rtems_task Task_2(
 			status = rtems_rate_monotonic_delete(RM_period);
 			if(status != RTEMS_SUCCESSFUL){
 				printf("BUG: Cannot delete the period 2\n");
-				exit(1);
+        rtems_test_exit(0);
 			}
 			/* The example is finished */
-			exit(1);
+      TEST_END();
+      rtems_test_exit(0);
 		}else{

 			startTick = rtems_clock_get_ticks_since_boot();
--
1.9.1


From 48c5c7787914c58ca8a58f6111f20cb427c4753d Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Fri, 5 Aug 2016 17:39:27 +0200
Subject: [PATCH 11/12] Fix the status counting in statistic

---
 cpukit/rtems/src/ratemonperiod.c               |  5 +-
 testsuites/sptests/sprmsched01/init.c          | 10 ++-
 testsuites/sptests/sprmsched01/sprmsched01.doc | 33 ++++++++++
 testsuites/sptests/sprmsched01/sprmsched01.scn | 46 ++++++++++++++
 testsuites/sptests/sprmsched01/system.h        |  9 ++-
 testsuites/sptests/sprmsched01/tasks.c         | 87 +++++++++-----------------
 6 files changed, 122 insertions(+), 68 deletions(-)
 create mode 100644 testsuites/sptests/sprmsched01/sprmsched01.doc
 create mode 100644 testsuites/sptests/sprmsched01/sprmsched01.scn

diff --git a/cpukit/rtems/src/ratemonperiod.c b/cpukit/rtems/src/ratemonperiod.c
index 124dd71..26cee58 100644
--- a/cpukit/rtems/src/ratemonperiod.c
+++ b/cpukit/rtems/src/ratemonperiod.c
@@ -299,11 +299,8 @@ static rtems_status_code _Rate_monotonic_Block_while_expired(
   /*
    * No matter the just finished jobs in time or not,
    * they are actually missing their deadlines already.
-   * However, maybe the latest postponed job is exactly
-   * the one released in the current period.
    */
-  if(the_period->postponed_jobs > 1)
-    the_period->state = RATE_MONOTONIC_EXPIRED;
+  the_period->state = RATE_MONOTONIC_EXPIRED;

   /*
    *  Update statistics from the concluding period
diff --git a/testsuites/sptests/sprmsched01/init.c b/testsuites/sptests/sprmsched01/init.c
index 48d6d0f..d454cf1 100644
--- a/testsuites/sptests/sprmsched01/init.c
+++ b/testsuites/sptests/sprmsched01/init.c
@@ -21,9 +21,16 @@
 #include "system.h"

 #include <rtems/rtems/tasksimpl.h>
+#include <rtems/test.h>
+#include <rtems/status-checks.h>

 const char rtems_test_name[] = "Rate Monotonic 01";

+/* Global variables */
+rtems_id   Task_id[ 2 ];         /* array of task ids */
+rtems_name Task_name[ 2 ];       /* array of task names */
+uint32_t tick_per_second;        /* time reference */
+int testnumber = 15;                  /* stop condition */

 #if 1
 rtems_task Init(
@@ -32,6 +39,8 @@ rtems_task Init(
 {
   TEST_BEGIN();
   rtems_status_code status;
+  rtems_time_of_day time;
+

   tick_per_second = rtems_clock_get_ticks_per_second();
   printf("\nTicks per second in your system: %" PRIu32 "\n", tick_per_second);
@@ -60,7 +69,6 @@ rtems_task Init(

   /* After creating the periods for tasks, start to run them sequencially. */

-  experiment_flag = 1;
   status = rtems_task_start( Task_id[ 1 ], Task_1, 1);
   if ( status != RTEMS_SUCCESSFUL) {
     printf( "rtems_task_start 1 failed with status of %d.\n", status );
diff --git a/testsuites/sptests/sprmsched01/sprmsched01.doc b/testsuites/sptests/sprmsched01/sprmsched01.doc
new file mode 100644
index 0000000..7153af8
--- /dev/null
+++ b/testsuites/sptests/sprmsched01/sprmsched01.doc
@@ -0,0 +1,33 @@
+#
+#   COPYRIGHT (c) 2016 Kuan-Hsun Chen, TU Dortmund University (TUDo).
+#
+#   The license and distribution terms for this file may be
+#   found in the file LICENSE in this distribution or at
+#   http://www.rtems.com/license/LICENSE.
+#
+
+This file describes the directives and concepts tested by this test set.
+
+test set name: sprmsched01
+
+directives:
+
+  - rtems_rate_monotonic_report_statistics()
+  - rtems_rate_monotonic_period()
+  - rtems_rate_monotonic_Postponed_num()
+  - _Rate_monotonic_Timeout()
+  - _Rate_monotonic_Renew_deadline()
+  - _Rate_monotonic_Release_postponedjob()
+  - _Rate_monotonic_Block_while_expired()
+
+
+concepts:
+
+  - Verify that watchdog deadline is renewed on time without shift via
+    _Rate_monotonic_Renew_deadline().
+  - Verify that postponed jobs are released with a correct number via
+    _Rate_monotonic_Release_postponedjob().
+  - Verify that rtems_rate_monotonic_report_statistics() reports correct number
+    of deadline misses.
+  - Verify that rtems_rate_monotonic_period() and
+    _Rate_monotonic_Block_while_expired() are operational.
diff --git a/testsuites/sptests/sprmsched01/sprmsched01.scn b/testsuites/sptests/sprmsched01/sprmsched01.scn
new file mode 100644
index 0000000..414112a
--- /dev/null
+++ b/testsuites/sptests/sprmsched01/sprmsched01.scn
@@ -0,0 +1,46 @@
+
+
+*** BEGIN OF TEST Rate Monotonic 01 ***
+
+Ticks per second in your system: 1000
+Task 1 starts at tick 13.
+                                        Task 1 ends at tick 6013.
+Task 2 starts at tick 6014.
+                                        Job 1 Task 2 ends at tick 7014.
+Task 2 starts at tick 8014.
+                                        Job 2 Task 2 ends at tick 9014.
+Task 1 starts at tick 10013.
+                                        Task 1 ends at tick 16013.
+Task 2 starts at tick 16014.
+                                        Job 3 Task 2 ends at tick 17014.
+Task 2 starts at tick 17014.
+                                        Job 4 Task 2 ends at tick 18014.
+Task 2 starts at tick 18014.
+                                        Job 5 Task 2 ends at tick 19014.
+Task 2 starts at tick 19014.
+                                        Job 6 Task 2 ends at tick 20014.
+Task 2 starts at tick 20014.
+                                        Job 7 Task 2 ends at tick 21014.
+Task 2 starts at tick 21014.
+                                        Job 8 Task 2 ends at tick 22014.
+Task 2 starts at tick 22014.
+                                        Job 9 Task 2 ends at tick 23014.
+Task 2 starts at tick 24014.
+                                        Job 10 Task 2 ends at tick 25014.
+Task 2 starts at tick 26014.
+                                        Job 11 Task 2 ends at tick 27014.
+Task 2 starts at tick 28014.
+                                        Job 12 Task 2 ends at tick 29014.
+Task 2 starts at tick 30014.
+                                        Job 13 Task 2 ends at tick 31014.
+Task 2 starts at tick 32014.
+                                        Job 14 Task 2 ends at tick 33014.
+Task 2 starts at tick 34014.
+                                        Job 15 Task 2 ends at tick 35014.
+Period information by period
+--- CPU times are in seconds ---
+--- Wall times are in seconds ---
+   ID     OWNER COUNT MISSED          CPU TIME                  WALL TIME
+                                    MIN/MAX/AVG                MIN/MAX/AVG
+0x42010002 TA2     15      5 0.999841/6.999920/2.399988 0.999848/13.000245/5.200154
+*** END OF TEST Rate Monotonic 01 ***
diff --git a/testsuites/sptests/sprmsched01/system.h b/testsuites/sptests/sprmsched01/system.h
index b99b74a..12fc62f 100644
--- a/testsuites/sptests/sprmsched01/system.h
+++ b/testsuites/sptests/sprmsched01/system.h
@@ -39,11 +39,10 @@ rtems_task Task_2(
  *  Keep the names and IDs in global variables so another task can use them.
  */

-TEST_EXTERN rtems_id   Task_id[ 2 ];         /* array of task ids */
-TEST_EXTERN rtems_name Task_name[ 2 ];       /* array of task names */
-TEST_EXTERN uint32_t tick_per_second;        /* time reference */
-TEST_EXTERN int testnumber;                  /* stop condition */
-TEST_EXTERN int experiment_flag;             /* flag for halting the experiment */
+extern rtems_id   Task_id[ 2 ];         /* array of task ids */
+extern rtems_name Task_name[ 2 ];       /* array of task names */
+extern uint32_t tick_per_second;        /* time reference */
+extern int testnumber;                  /* stop condition */

 /* configuration information */

diff --git a/testsuites/sptests/sprmsched01/tasks.c b/testsuites/sptests/sprmsched01/tasks.c
index 3eb488f..177a5a9 100644
--- a/testsuites/sptests/sprmsched01/tasks.c
+++ b/testsuites/sptests/sprmsched01/tasks.c
@@ -26,10 +26,6 @@
 #endif

 #include "system.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <rtems.h>
-#include <rtems/rtems/tasksimpl.h>

 /* CPU usage and Rate monotonic manger statistics */
 #include "rtems/cpuuse.h"
@@ -56,10 +52,9 @@ rtems_task Task_1(
   rtems_status_code status;
   rtems_name        period_name;
   rtems_id          RM_period;
-  rtems_id 			selfid=rtems_task_self();
-  double            start, end;
-  int		    	tsk_counter = 0;
-  int		    	startTick = 0;
+  rtems_id          selfid=rtems_task_self();
+  int               start, end;
+  int		    	      tsk_counter = 0;

   /*create period*/
   period_name = rtems_build_name( 'P', 'E', 'R', '1' );
@@ -70,36 +65,27 @@ rtems_task Task_1(
   }

 	while( 1 ) {
-		status = rtems_rate_monotonic_period( RM_period,PERIOD_TASK_1);
-
-		if(tsk_counter == 2){
-
+		if(tsk_counter == 2){
 				status = rtems_rate_monotonic_delete(RM_period);
 				if(status != RTEMS_SUCCESSFUL){
 					printf("BUG: Cannot delete the period 1\n");
           rtems_test_exit(0);
 				}
-
-				status=rtems_task_delete(selfid);
-				if(status != RTEMS_SUCCESSFUL){
-					printf("BUG: Cannot delete the task 1\n");
+
+        status=rtems_task_delete(selfid);
+        if(status != RTEMS_SUCCESSFUL){
+          printf("BUG: Cannot delete the task 1\n");
           rtems_test_exit(0);
-				}
-
-		}else{
-
-			startTick = rtems_clock_get_ticks_since_boot();
-			start = startTick  / (double)tick_per_second;
-
-			printf("Task 1 starts current second %.6f.\n", start);
-
-			LOOP(task_1_normal_et,task_id);
-
-			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
-
-			printf("					Task 1 ends at current second  %.6f .\n", end);
- 			tsk_counter += 1;
-		}
+        }
+
+    }
+		status = rtems_rate_monotonic_period( RM_period,PERIOD_TASK_1);
+    start = rtems_clock_get_ticks_since_boot();
+    printf("Task 1 starts at tick %d.\n", start);
+    LOOP(task_1_normal_et,task_id);
+    end = rtems_clock_get_ticks_since_boot();
+    printf("					Task 1 ends at tick %d.\n", end);
+    tsk_counter += 1;
 	}
 }

@@ -113,9 +99,8 @@ rtems_task Task_2(
   rtems_status_code status;
   rtems_name        period_name;
   rtems_id          RM_period;
-  double 	        start, end;
-  int		        tsk_counter = 0;
-  int		        startTick = 0;
+  int               start, end;
+  int		            tsk_counter = 0;

   /*create period*/

@@ -127,11 +112,10 @@ rtems_task Task_2(
   }

 	while( 1 ) {
-
-		/*this part for release offset*/
+
 		status = rtems_rate_monotonic_period( RM_period, PERIOD_TASK_2);
-
-		if(experiment_flag ==0){
+  	if(tsk_counter == testnumber){
+		  rtems_rate_monotonic_report_statistics();
 			status = rtems_rate_monotonic_delete(RM_period);
 			if(status != RTEMS_SUCCESSFUL){
 				printf("BUG: Cannot delete the period 2\n");
@@ -140,26 +124,13 @@ rtems_task Task_2(
 			/* The example is finished */
       TEST_END();
       rtems_test_exit(0);
-		}else{
-
-			startTick = rtems_clock_get_ticks_since_boot();
-			start = startTick  / (double)tick_per_second;
-
-			printf("Task 2 starts at current second %.6f.\n", start);
-
-			LOOP(task_2_normal_et,task_id);
-
-			end = rtems_clock_get_ticks_since_boot()/(double)tick_per_second;
-
-			printf("					%d Task 2 ends at current second %.6f.\n", tsk_counter+1, end);
-
-			tsk_counter += 1;
-
-			if(tsk_counter == testnumber){
-			  rtems_rate_monotonic_report_statistics();
-			  experiment_flag=0;
-			}
 		}
+    start = rtems_clock_get_ticks_since_boot();
+    printf("Task 2 starts at tick %d.\n", start);
+    LOOP(task_2_normal_et,task_id);
+    end = rtems_clock_get_ticks_since_boot();
+    printf("					Job %d Task 2 ends at tick %d.\n", tsk_counter+1, end);
+    tsk_counter += 1;
 	}
 }

--
1.9.1


From 826cc0b45a69c6055f4f52b705d0764b007d3f32 Mon Sep 17 00:00:00 2001
From: KHCHEN <kuan-hsun.chen@tu-dortmund.de>
Date: Fri, 5 Aug 2016 20:19:02 +0200
Subject: [PATCH 12/12] Remove trailing whitespace

---
 cpukit/rtems/include/rtems/rtems/ratemon.h     |  8 ++---
 cpukit/rtems/include/rtems/rtems/ratemonimpl.h |  2 +-
 cpukit/rtems/src/ratemonperiod.c               | 44 +++++++++++++-------------
 cpukit/rtems/src/ratemontimeout.c              |  2 +-
 4 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/cpukit/rtems/include/rtems/rtems/ratemon.h b/cpukit/rtems/include/rtems/rtems/ratemon.h
index 71a99dc..5ebe3da 100644
--- a/cpukit/rtems/include/rtems/rtems/ratemon.h
+++ b/cpukit/rtems/include/rtems/rtems/ratemon.h
@@ -232,14 +232,14 @@ typedef struct {
   Rate_monotonic_Statistics               Statistics;

   /**
-   * This field contains the number of postponed jobs. When the watchdog timeout,
+   * This field contains the number of postponed jobs. When the watchdog timeout,
    * this variable will be increased immediately.
    */
   uint32_t                                postponed_jobs;

   /**
    *  This field contains the tick of the latest deadline decided by the period
-   *  watchdog.
+   *  watchdog.
    */
   uint64_t                                latest_deadline;

@@ -390,14 +390,14 @@ void rtems_rate_monotonic_report_statistics( void );

 /**
  * @brief RTEMS Return the number of postponed jobs
- *
+ *
  * This is a helper function to return the number of postponed jobs by this
  * given period. This number is only increased by the corresponding watchdog,
  * and is decreased by RMS manager with the postponed job releasing.
  *
  * @param[in] id is the period id
  *
- * @retval This helper function returns the number of postponed
+ * @retval This helper function returns the number of postponed
  * jobs with given period_id.
  *
  */
diff --git a/cpukit/rtems/include/rtems/rtems/ratemonimpl.h b/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
index 6cdaaeb..f7059ee 100644
--- a/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
+++ b/cpukit/rtems/include/rtems/rtems/ratemonimpl.h
@@ -121,7 +121,7 @@ bool _Rate_monotonic_Get_status(
  * @brief Renew the watchdog deadline
  *
  * This routine is prepared for the watchdog timeout to renew its deadline
- * without releasing jobs.
+ * without releasing jobs.
  */
 void _Rate_monotonic_Renew_deadline(
   Rate_monotonic_Control *the_period,
diff --git a/cpukit/rtems/src/ratemonperiod.c b/cpukit/rtems/src/ratemonperiod.c
index 26cee58..eba833d 100644
--- a/cpukit/rtems/src/ratemonperiod.c
+++ b/cpukit/rtems/src/ratemonperiod.c
@@ -75,7 +75,7 @@ static void _Rate_monotonic_Release_postponedjob(
   Per_CPU_Control *cpu_self;
   cpu_self = _Thread_Dispatch_disable_critical( lock_context );
   _Rate_monotonic_Release( owner, lock_context );
-
+
   the_period->postponed_jobs -=1;
   _Scheduler_Release_job( owner, the_period->latest_deadline );

@@ -229,7 +229,7 @@ static rtems_status_code _Rate_monotonic_Activate(
   ISR_lock_Context       *lock_context
 )
 {
-
+
   /* Initialize the number of postponed job variable */
   the_period->postponed_jobs = 0;

@@ -284,9 +284,9 @@ static rtems_status_code _Rate_monotonic_Block_while_active(
   return RTEMS_SUCCESSFUL;
 }

-/*
- * There are two possible cases: one is that the previous deadline is missed,
- * The other is that the number of postponed jobs is not 0, but the current
+/*
+ * There are two possible cases: one is that the previous deadline is missed,
+ * The other is that the number of postponed jobs is not 0, but the current
  * deadline is still not expired, i.e., state = RATE_MONOTONIC_ACTIVE.
  */
 static rtems_status_code _Rate_monotonic_Block_while_expired(
@@ -296,9 +296,9 @@ static rtems_status_code _Rate_monotonic_Block_while_expired(
   ISR_lock_Context       *lock_context
 )
 {
-  /*
-   * No matter the just finished jobs in time or not,
-   * they are actually missing their deadlines already.
+  /*
+   * No matter the just finished jobs in time or not,
+   * they are actually missing their deadlines already.
    */
   the_period->state = RATE_MONOTONIC_EXPIRED;

@@ -309,7 +309,7 @@ static rtems_status_code _Rate_monotonic_Block_while_expired(

   the_period->state = RATE_MONOTONIC_ACTIVE;
   the_period->next_length = length;
-
+
   _Rate_monotonic_Release_postponedjob( the_period, executing, length, lock_context );
   return RTEMS_TIMEOUT;
 }
@@ -317,7 +317,7 @@ static rtems_status_code _Rate_monotonic_Block_while_expired(
 uint32_t rtems_rate_monotonic_Postponed_num(
     rtems_id   period_id
 )
-{
+{
   Rate_monotonic_Control             *the_period;
   ISR_lock_Context                    lock_context;
   Thread_Control                     *owner;
@@ -364,14 +364,14 @@ rtems_status_code rtems_rate_monotonic_period(
       case RATE_MONOTONIC_ACTIVE:

         if(the_period->postponed_jobs > 0){
-          /*
-           * If the number of postponed jobs is not 0, it means the
-		   * previous postponed instance is finished without exceeding
-		   * the current period deadline.
+          /*
+           * If the number of postponed jobs is not 0, it means the
+		   * previous postponed instance is finished without exceeding
+		   * the current period deadline.
            *
-           * Do nothing on the watchdog deadline assignment but release the next
+           * Do nothing on the watchdog deadline assignment but release the next
            * remaining postponed job.
-           */
+           */
           status = _Rate_monotonic_Block_while_expired(
             the_period,
             length,
@@ -379,10 +379,10 @@ rtems_status_code rtems_rate_monotonic_period(
             &lock_context
           );
         }else{
-          /*
-           * Normal case that no postponed jobs and no expiration, so wait for the period
+          /*
+           * Normal case that no postponed jobs and no expiration, so wait for the period
            * and update the deadline of watchdog accordingly.
-           */
+           */
           status = _Rate_monotonic_Block_while_active(
             the_period,
             length,
@@ -400,11 +400,11 @@ rtems_status_code rtems_rate_monotonic_period(
         );
         break;
       default:
-        /*
-         * As now this period was already TIMEOUT, there must be at least one
+        /*
+         * As now this period was already TIMEOUT, there must be at least one
          * postponed job recorded by the watchdog. The one which exceeded
          * the previous deadline"s" was just finished.
-         *
+         *
          * Maybe there is more than one job postponed due to the preemption or
          * the previous finished job.
          */
diff --git a/cpukit/rtems/src/ratemontimeout.c b/cpukit/rtems/src/ratemontimeout.c
index be0a770..d26e663 100644
--- a/cpukit/rtems/src/ratemontimeout.c
+++ b/cpukit/rtems/src/ratemontimeout.c
@@ -64,7 +64,7 @@ void _Rate_monotonic_Timeout( Watchdog_Control *the_watchdog )
       _Thread_Unblock( owner );
     }
   } else {
-    /*
+    /*
      * If the watchdog is timeout, it means there is an additional postponed
      * job in the next period but it is not available to release now:
      * Either the current task is still executed, or it is preemptive by the
--
1.9.1

